\documentclass{article}
\usepackage{animate}
\usepackage{biblatex}
\usepackage{cancel}
\usepackage{float}
%\usepackage{gensymb}
\usepackage[margin=1in, top=1in, bottom=1in]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{tikz}
\usepackage{tikzit}
% \usetikzlibrary{external}
% \tikzexternalize[optimize=false,prefix=figures/cache/] % activate and define figures/ as cache folder
\input{preamble.tex}
\input{zx.tikzstyles}

\def\tikzscale{1.5}

\usepackage[T1]{fontenc}
\usepackage[skins,hooks,xparse,breakable]{tcolorbox}
\usepackage{svg}
\usepackage{xcolor}
\usepackage{chngcntr}

\addbibresource{qiskit+zx.bib}

\newcounter{examplecounter}
\counterwithin{examplecounter}{section}

\usetikzlibrary{calc}

\definecolor{greentitle}{RGB}{61,170,61}
\definecolor{greentitleback}{RGB}{216,233,213}
\definecolor{drakgreentitle}{RGB}{24,131,80}

\DeclareTColorBox{example}{O{}o}{
    enhanced,
    breakable,
    arc=0pt,
    boxrule=0pt,
    colback=white,
    top=3em, % you can change the top spacing
    overlay unbroken and first={
        % draw box on the left
        \node[fill=greentitleback,
            font=\color{greentitle}\sffamily\bfseries\large,
            anchor=south west,
            xshift=2mm,
            yshift=-2.2em, % you can change xshift and yshift to adjust the title placement
        ] (titlebox) at (frame.north west) 
        {Example \refstepcounter{examplecounter}\theexamplecounter
        % add cross-referencing support
        \IfValueT{#2}{\label{#2}}
        };
        
        % write title on the right
        \node[font=\color{drakgreentitle}\sffamily\large, 
        anchor=west
        ] at ($(titlebox.east)+(2mm,0mm)$) {#1};
        
        % draw the vertical line on the left
        \draw[draw=greentitleback, line width=2pt] 
            (titlebox.north west-|frame.north west)--(frame.south west);
    },
    overlay middle and last={
        \draw[draw=greentitleback, line width=2pt] 
            (frame.north west)--(frame.south west);
    }
    fonttitle=\color{greentitle}\sffamily\bfseries,
}
\newcommand{\soln}{{\\[1em] \hspace{-1em}\color{greentitle}\sffamily\large Solution: \\[0.5em]}}

\definecolor{redtitle}{RGB}{170,61,61}
\definecolor{redtitleback}{RGB}{233,213,216}
\definecolor{drakredtitle}{RGB}{131,80,24}
\newcounter{zxrulecounter}
\counterwithin{zxrulecounter}{section}
\DeclareTColorBox{zxrule}{O{}o}{
    enhanced,
    breakable,
    arc=0pt,
    boxrule=0pt,
    colback=white,
    top=3em, % you can change the top spacing
    overlay unbroken and first={
        % draw box on the left
        \node[fill=redtitleback,
            font=\color{redtitle}\sffamily\bfseries\large,
            anchor=south west,
            xshift=2mm,
            yshift=-2.2em, % you can change xshift and yshift to adjust the title placement
        ] (titlebox) at (frame.north west) 
        {ZX-calculus Rule \refstepcounter{zxrulecounter}\thezxrulecounter
        % add cross-referencing support
        \IfValueT{#2}{\label{#2}}
        };
        
        % write title on the right
        \node[font=\color{drakredtitle}\sffamily\large, 
        anchor=west
        ] at ($(titlebox.east)+(2mm,0mm)$) {#1};
        
        % draw the vertical line on the left
        \draw[draw=redtitleback, line width=2pt] 
            (titlebox.north west-|frame.north west)--(frame.south west);
    },
    overlay middle and last={
        \draw[draw=redtitleback, line width=2pt] 
            (frame.north west)--(frame.south west);
    }
    fonttitle=\color{redtitle}\sffamily\bfseries,
}

\definecolor{graytitle}{RGB}{170,170,170}
\definecolor{graytitleback}{RGB}{233,233,233}
\definecolor{drakgraytitle}{RGB}{131,131,131}
\newcounter{notecounter}
\counterwithin{notecounter}{section}
\DeclareTColorBox{note}{O{}o}{
    enhanced,
    breakable,
    arc=0pt,
    boxrule=0pt,
    colback=white,
    top=3em, % you can change the top spacing
    overlay unbroken and first={
        % draw box on the left
        \node[fill=graytitleback,
            font=\color{graytitle}\sffamily\bfseries\large,
            anchor=south west,
            xshift=2mm,
            yshift=-2.2em, % you can change xshift and yshift to adjust the title placement
        ] (titlebox) at (frame.north west) 
        {Note \refstepcounter{notecounter}\thenotecounter
        % add cross-referencing support
        \IfValueT{#2}{\label{#2}}
        };
        
        % write title on the right
        \node[font=\color{drakgraytitle}\sffamily\large, 
        anchor=west
        ] at ($(titlebox.east)+(2mm,0mm)$) {#1};
        
        % draw the vertical line on the left
        \draw[draw=graytitleback, line width=2pt] 
            (titlebox.north west-|frame.north west)--(frame.south west);
    },
    overlay middle and last={
        \draw[draw=graytitleback, line width=2pt] 
            (frame.north west)--(frame.south west);
    }
    fonttitle=\color{graytitle}\sffamily\bfseries,
}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\newcommand*\conj[1]{\bar{#1}}
\newcommand{\abs}[1]{{\big\vert} #1 {\big\vert}}
\newcommand{\kz}[1]{\ket{\,#1\,}}
\newcommand{\kx}[1]{\ket{#1}}
\newcommand{\bz}[1]{\bra{\,#1\,}}
\newcommand{\bx}[1]{\bra{#1}}
\newcommand{\gate}[1]{\textbf{\textsf{#1}}}
\newcommand{\mkzero}{\begin{bmatrix}1\\ 0\end{bmatrix}}
\newcommand{\mkone}{\begin{bmatrix}0\\ 1\end{bmatrix}}
\newcommand{\mkplus}{\large{\frac{1}{\sqrt{2}}}\begin{bmatrix}1\\ 1\end{bmatrix}}
\newcommand{\mkminus}{\large{\frac{1}{\sqrt{2}}}\begin{bmatrix}1\\ -1\end{bmatrix}}
\newcommand{\mab}[2]{\begin{bmatrix}#1\\ #2\end{bmatrix}}
\newcommand{\transpose}{\text{T}}

\begin{document}

\tableofcontents

\section{A bit of quantum}
\subsubsection{A \textbf{bit} of information}
Say you were asked, ``Do you like pineapple on pizza?'', and you could respond only with either ``Yes'' or ``No''.
In other words, you can only give one \textbf{bit} of information in response.
A \textbf{bit} can have one of two possible values.  For example, these two values could be yes or no, true or false, on or off,...
In computers, we call these two possible values 0 and 1.  If we have many bits, we can store many possible values.

As an analogy, whenever you flip a light switch, you expect to either turn on a lightbulb, or turn off a lightbulb.
Flipping the light switch thus flips the \textbf{bit} that represents the state of the lightbulb, between ``on'' and ``off'.
Likewise, your computer is built from billions of these switches, called \textit{transistors}, like in Figure \ref{fig:tsmc}.
\begin{figure}[H]%%%note don't have permissions to use this image
	\label{fig:tsmc}
	\includegraphics[width=\columnwidth]{images/rainbowtsmc.jpg}
	\caption{This semiconductor chip made by TSMC has been magnified exorbitantly.  Each transistor in this chip is so small, that if you lined up a thousand of them from end to end, it would be smaller than the width of a human hair.}
\end{figure}

\subsection{Diagrams}
We use diagrams to describe what happens to a system over time.  We use here the convention of reading diagrams from bottom (earliest time) to top (latest time).
\subsubsection{\textbf{Boxes} and \textbf{wires}}
In diagrams, each \textbf{wire} carries information.  They can represent physical wires, such as the electrical wire which connects your light switch to your lightbulb.  They can also represent imaginary wires, such as the sound waves when you verbally answer the question, ``Do you like pineapple on pizza?''
A \textbf{box} in our diagram represents a process: something that transforms inputs into outputs.
These inputs and outputs are our wires.  Each wire has a \textbf{type}, and each input and output of a process must be of the right type.  For instance, for the process of doing laundry, the inputs and outputs are your clothes; you wouldn't put your trash through the laundry (hopefully).
We draw boxes as trapezoids; shortly, we will see why this way of drawing them is useful.

This box represents the switch process, which flips the input bit:
\begin{equation*}{\scalebox{\tikzscale}{\tikzfig{switch_process}}}\end{equation*}
\subsubsection{\textbf{States} and \textbf{tests}}
A \textbf{state} is a process with no inputs.  In our diagrams, we draw a state as an isosceles triangle with the output wires on the base of the triangle.

A lightbulb has two possible states: on and off.  If we wire up a lightbulb to our switch, flipping the switch turns on the lightbulb:
\begin{equation}
\label{eq:switch_on}
{\scalebox{\tikzscale}{\tikzfig{switch_on}}}
\end{equation}
Likewise, we can flip the switch connected to a lit lightbulb to turn it off:
\begin{equation}
\label{eq:switch_off}
{\scalebox{\tikzscale}{\tikzfig{switch_off}}}
\end{equation}
A \textbf{test}\footnote{In the wild\cite{PQP}, another word for it is \textbf{effect}.} is a process with no outputs.  When a test is applied to a state, it tests how likely the corresponding outcome is to occur.

In our diagrams, we draw a test as an upside-down state: an isosceles triangle with the input wires on the base of the triangle.  To apply a test to a state, we connect the state and the test with a wire.  This way, the output of the state is the same as the input to the test.  In total, our diagram with a test applied to a state has zero inputs and zero outputs --- this is called a \textbf{number}.  This number encodes the probability that given that state, the outcome observed is the outcome being tested for.

For our lightbulb example, when the test matches the state, this number equals 1:
\begin{equation}
{\scalebox{\tikzscale}{\tikzfig{lightbulb_test00}}}
\end{equation}

\begin{equation}
\label{eq:lightbulb_test11}
{\scalebox{\tikzscale}{\tikzfig{lightbulb_test11}}}
\end{equation}
On the other hand, when the test is the opposite of the state, this number equals 0:
\begin{equation}
{\scalebox{\tikzscale}{\tikzfig{lightbulb_test01}}}
\end{equation}
\begin{equation}
{\scalebox{\tikzscale}{\tikzfig{lightbulb_test10}}}
\end{equation}

\subsubsection{Rewriting diagrams with equations}
What can we do with diagrams which are equal to each other?
The answer: If we have two equal diagrams, whenever we see one of them, we can replace it with the other.

This is handy in simplifying diagrams.  Below, we replace the diagram in the gray dashed box with a diagram equal to it, according to Equation \ref{eq:switch_on}.  We can then use Equation \ref{eq:lightbulb_test11} to rewrite the diagram to the number 1.  In other words, given the information that the lightbulb is working, we showed that after you flip the light switch connected to the off lightbulb, the probability that you observe the lightbulb to be on is 1.
\begin{equation}
{\scalebox{\tikzscale}{\tikzfig{lightbulb_simp}}}
\end{equation}

\subsection{Classical logic gates}
The transistors in your phone are constantly performing binary logic gates such as the NOT gate in our light switch example.  \textit{Binary} means that each input or output of these gates is one of two possible values, which we call 0 and 1 --- a bit.

While the NOT gate has just one input, a binary logic gate can have more than one input.  Given the question ``Would you like tea or cookies?'', a programmer with a sense of humor could respond ``Yes'' or ``No''.  If you are thinking of the question as computing an OR gate\footnote{For some people, ``or'' in casual conversation is meant as either-or (a.k.a. mutually-exclusive-or a.k.a. XOR).  For clarity we'll use logic in conversation here taking them to have the same meaning as they do in binary logic, despite the many exceptions in colloquial English.}, your two inputs are 1) whether you would like tea, and 2) whether you would like cookies.  If you would like tea and no cookies, you would answer ``Yes''.  If you would like cookies and no tea, you would also answer ``Yes''.  If you would like both tea and cookies, you would answer ``Yes''.  If you would like neither tea nor cookies, you would answer ``No''.

Like computer engineers do, we can use a circuit diagram to show the inputs and outputs.  The conventional circuit diagram symbol for the binary OR logic gate is shown in Figure \ref{ref:teaorcookies}.

\begin{figure}[H]
	\ctikzfig{teaorcookies}
	\caption{The OR gate here is drawn as its conventional circuit diagram symbol.  It has two input bits and one output bit.  For instance, if the two inputs are ``Yes'' for liking tea and ``No'' for liking cookies, the output is therefore ``Yes'' for liking tea or cookies.}
	\label{ref:teaorcookies}
\end{figure}

We can also compactly list the above logic in a table called a \textit{truth table}.  A truth table for a logic gate has two columns: it displays the output(s) in the right column, given the input(s) in the left column.  We will use the convention of 1 meaning ``Yes'', and 0 meaning ``No''.  By letting 1) whether you would like tea, and 2) whether you would like cookies, be your two inputs, the right column of the truth table for the OR gate gives whether your answer to ``Would you like tea or cookies?'' is ``Yes'' or ``No''.  Figure \ref{fig:classical_logic_gates} gives the circuit diagram and truth table of the OR gate, and several of the other most important binary logic gates.
\begin{figure}[H]
	\ctikzfig{classical_logic_gates}
	\caption{Although it would be cumbersome to do so, you can directly express all computation done by your phone in terms of the gates here.  On the left side are the four diagrams representing the NOT, AND, OR, and XOR (``either or'') gate respectively.  The input(s) to each gate are on its left, and the output(s) are on its right.  On the right side, the \textit{truth table} for each gate is given.}
	\label{fig:classical_logic_gates}
\end{figure}

As their inputs and outputs are all bit(s), you can apply these gates one after another.  For instance, when we apply the NOT gate after the AND gate, we get the NAND (``not and'') gate:
\begin{equation}
	\tikzfig{nand}
\end{equation}

Likewise, applying the NOT gate after the OR gate yields the NOR (``not or'') gate:
\begin{equation}
	\tikzfig{nor}
\end{equation}

The NAND gate is \textbf{universal}.  This means that you can do \underline{any} computation on bits using just this one gate.  The NOR gate is also universal.  Indeed, you can build all the necessary components of a computer of just NAND gates, and there are texts on how to do exactly that.  Putting physical hardware limitations aside, this concept of universality is important in quantum computing to know whether the quantum gates you can perform can be applied in such a way as to implement any quantum circuit.

Furthermore, different circuits can perform the exact same logical operation.
The simplest example is that two NOT gates is the same computation as applying no gates at all:
\begin{equation}
	\label{eq:notnot}
	\tikzfig{notnot}
\end{equation}

Another example, well-known for binary operations, is \textit{deMorgan's laws}.  Given two bits \textsf{A} and \textsf{B}, deMorgan's laws consists of two equations:
\begin{align}
	\text{NOT(\textsf{A} AND \textsf{B})} &= \text{(NOT \textsf{A}) OR (NOT \textsf{B})} \\
	\text{NOT(\textsf{A} OR \textsf{B})} &= \text{(NOT \textsf{A}) AND (NOT \textsf{B})}
\end{align}
You can check that these equations are correct by determining the truth table for both sides of the equation, then verifying that the truth tables are identical.  Given truth tables of all the gates in the circuit, you can obtain the truth table of the circuit via the following steps.  These steps are given for your reference as it may be helpful to be aware of truth tables when learning about quantum logic gates; however, we will not ask you to do this computation as it is rather tedious --- exponentially so in the number of input bits.
\begin{enumerate}
	\item Write all possible inputs in the left column.  For $n$ input bits, there should be $2^n$ possible inputs, because each bit can be either 0 or 1.
	\item Choose a row of the truth table where the right column is empty, and set the bits of the inputs according to its left column.
	\item Starting from the leftmost gates, from the gate's input(s), determine its output bit.  This can be done by looking up the truth table for that gate.
	\item Pass on that gate's output as an input to the next gate, and repeat Step 3 for the next gate.  If there is no next gate, then this bit is an output bit.
	\item When you have determined each output bit for these specific input bits, write the output in the right column of the row of the truth table you chose in Step 2.
	\item Repeat Steps 2 to 5 until the truth table is complete.
\end{enumerate}

The more gates involved, the harder it is to keep track of all the parentheses.  This is where circuit diagrams come in handy to clearly and fully describe deMorgan's laws:
\begin{align}
	{\scalebox{0.84}{\tikzfig{demorganslaw1}}} \\
	{\scalebox{0.84}{\tikzfig{demorganslaw2}}} \label{eq:demorganslaw2}
\end{align}

Most importantly of all, we can use these \textit{diagram rewrite rules} to simplify a circuit to one that does the exact same computation.  As an added bonus, being proficient at this helps us better understand the computation at hand.

\newpage
\begin{example}[]
\label{example:nnorn}
Without actually computing any truth table(s), what is the truth table of the circuit in this diagram?
\begin{figure}[H]
	\ctikzfig{nnorn}
	\caption{The circuit which Example \ref{example:nnorn} asks to find the truth table for}
	\label{fig:nnorn}
\end{figure}

\textnormal{Thankfully, with the circuit diagram rewrite rules we have so far, we are ready to tackle this problem.  Whenever we draw a gray dashed box around a part of the diagram, it means that in the next step, we will substitute for that part of the diagram, another diagram which accomplishes the same computation.  The equation number of the diagram rewrite rule which permitted us to do this substitution is then indicated above the next equals sign.
\begin{equation}
\tikzfig{nnorn_simp1}
\end{equation}
\begin{equation}
\tikzfig{nnorn_simp2}
\end{equation}
\begin{equation}
\tikzfig{nnorn_simp3}
\end{equation}
Therefore, the given circuit has the same truth table as the AND gate.
}
\end{example}

One observation to point out is that some of these classical logic gates are not \textit{reversible}.  For a gate $g$ to be reversible, there must exist a gate $g'$ (which can be same as or different to $g$) that can ``undo'' the computation done by $g$.  In other words, applying $g'$ after $g$ should be the same as if you applied no gates, i.e. the identity operation.  When you have more input bits than output bits, there are more possible inputs than possible outputs; therefore the gate cannot be reversible, as there is at least one possible output for which it is impossible to uniquely determine what the input was.

Fun fact: the information lost when an irreversible gate is performed is dissipated as heat energy.  Next time your phone or computer heats up when performing intense computation, you know why.


\section{A \textbf{qubit} of information}
\subsection{Classical states and tests}
Having learned about states and tests in general, we are now ready to start tackling quantum states and tests.  Alongside gaining intuition from our diagrams, we will learn how to use \textit{bra-ket notation} (also called Dirac notation, as it was created by Paul Dirac so a physicist could represent vectors).  Thankfully, this new jargon is simple: kets are what we call states, and bras are what we call tests.

Just as a bit is the smallest unit of information in a computer, a \textbf{qubit} is the smallest unit of information in a quantum computer.
We can encode any bit as a qubit by mapping a bit with value 0 to the $\kz0$ (pronounced ``ket 0'') qubit state, and a bit with value 1 to the $\kz1$ (pronounced ``ket 1'') qubit state.  These are defined as:
\begin{align}
\label{eq:ket0}
&\tikzfig{ket0}\\
&\tikzfig{ket1}
\label{eq:ket1}
\end{align}

Let us plot them on the unit circle of the real 2D plane.
\begin{figure}[H]
	\ctikzfig{unitcircle01}
	\caption{$\kz0$ and $\kz1$ are plotted here on the unit circle.  This is just directly plotting their statevectors in 2D.}
	\label{fig:unitcircle}
\end{figure}
Let us note a few of their properties:
\begin{itemize}
\item They are \textit{orthogonal}: on the unit circle there is a right angle between them.
\item They are \textit{normalized}: they have a vector norm, or length, of 1.
\item They \textit{span} the real 2D plane: you can get any arbitrary 2D vector $\vec{v}$ of real numbers by taking their linear combination
\begin{align}
	\ket{v} &= a \kz0 + b \kz1\\
	&= a \mkzero + b \mkone\\
	&= \mab{a}{b}
\end{align}
where $a$ and $b$ are complex numbers\footnote{Mathematicians might call them coefficients, and physicists might call them probability amplitudes.}.
\end{itemize}
They form an \textbf{orthonormal basis} for $\mathbb{R}_2$, the \textit{vector space} of real 2D vectors.
We call this basis the \textbf{computational basis} because they encode a qubit as a bit.

Apart from the unit circle, another way to visualize these two states is on a sphere called the \textbf{Bloch sphere}, which looks like:
\begin{figure}
	\ctikzfig{blochxyz}	
	\caption{This is what the Bloch sphere looks like.}
	\label{fig:blochsphere}
\end{figure}
In addition to calling this basis for qubit states the computational basis, we also call it the \textbf{Z basis}.  This is because the states $\kz0$ and $\kz1$, called the \textit{Z-basis states}, are respectively on the positive and negative z-axis of the Bloch sphere.
\begin{figure}
	\ctikzfig{bloch01}
	\caption{$\kz0$ and $\kz1$ are plotted here on the Bloch sphere.}
\end{figure}
You might notice that on the Bloch sphere, the angle between these two states is $\pi$, or $180^{\degree}$.  However, when you take the inner product of the vectors in Equations \ref{eq:ket0} and \ref{eq:ket0}, or plot them on the unit circle as in Figure \ref{fig:unitcircle}, the angle between these two states' vectors is $\frac{\pi}{2}$ radians ($90^{\degree}$).
Indeed, any angle on the Bloch sphere is twice what it would be if we had plotted the vector in 2D.
While this may seem like an unnecessary complication now, we will later see how the Bloch sphere helps us visualize when our qubit states contain \textit{complex numbers}.
Throughout this text we will use radians instead of degrees, and adopt the convention of angles being angles on the Bloch sphere.

\subsubsection{The qubit NOT gate}
Recall how earlier in Equations \ref{eq:switch_on} and \ref{eq:switch_off}, we modelled how a light switch is a process which turns on an off lightbulb, and turns off an on lightbulb?
That is the NOT operation on a bit.
On a qubit, we also have a NOT operation which behaves as you expect:
\begin{equation}
	\tikzfig{ket0switch}
\end{equation}
\begin{equation}
	\tikzfig{ket1switch}
\end{equation}
When your qubit is in one of the classical states (corresponding to the two possible values a bit can have on a classical computer), the NOT gate is the bit flip gate: if you interpret 0 as false and 1 as true, then not true is false and not false is true.  The NOT gate flips the $\kz0$ state to the $\kz1$ state, and the $\kz1$ state to the $\kz0$ state.

What does the NOT gate do to a qubit state in general?  What it does is rotate the state vector on the Bloch sphere half a rotation about the x-axis; the axes are labelled in Figure \ref{fig:blochsphere}.  That is why the NOT gate is also called the \textbf{X gate}, as we will call it from now on.

As in our lightbulb example, when we flip a diagram of a state upside-down, we get a diagram of a test.
Flipping our diagrams of $\kz0$ and $\kz1$ in Equations \ref{eq:ket0} and \ref{eq:ket1} upside-down gives $\bz0$ (``bra 0'') and $\bz1$ (``bra 1'') respectively:
\begin{align}
&\tikzfig{bra0}\\
&\tikzfig{bra1}
\end{align}

We can connect the wire from state to test to get a number:
\begin{align}
	&\tikzfig{braket00} \label{eq:braket00} \\
	&\tikzfig{braket01} \label{eq:braket01} \\
	&\tikzfig{braket10} \label{eq:braket10} \\
	&\tikzfig{braket11} \label{eq:braket11} 
\end{align}
This number is the \text{inner product} of the bra vector and the ket vector.

You can observe one similarity between bra-ket notation here and conditional probability: the notation of a vertical line in-between.  For events \textsf{A} and \textsf{B},
\begin{equation}
	\text{Pr}(\,\textsf{A}\,|\,\textsf{B}\,) \coloneqq \text{Probability of \textsf{A} given \textsf{B}}
\end{equation}
This is by design.  In general, given a \textit{normalized}\footnote{We'll give a mathematical definition of this later.  Intuitively, you want your states and tests to be normalized so that you don't break the rules of the universe governing probabilities.} state $\ket{\,s\,}$ and test $\bra{\,t\,}$ pair, the probability that you observe the outcome $\bra{\,t\,}$ you were testing for, given the state is $\ket{\,s\,}$, is
\begin{equation}
	\label{eq:braketprob}
	\text{Pr}(\,t\,|\,s\,) = \abs{\langle \,t\,|\,s\,\rangle}^2
\end{equation}
This inner product is also called a \textbf{probability amplitude}, or amplitude for short.  The word "probability" follows form how you can always calculate the probability given a probability amplitude using Equation~\ref{eq:braketprob}, i.e. the probability is the \textit{norm-squared} of the probability amplitude.  This definition applies even when the probability amplitudes are complex numbers.  For now, we will stick with probability amplitudes which are real numbers, in which case the probability is simply the probability amplitude squared.

On the other hand, it can help to think of the word "amplitude" visually.  When you have a state drawn on the unit circle, you can draw a vertical line to the x-axis.  The height of the right triangle you just formed is the probability amplitude when you test for the $\kz1$ state given your state.  Likewise, the base of that right triangle is the probability amplitude when you test for the $\kz0$ state.
\begin{figure}[H]
	\ctikzfig{unitcircletrinoangle}
	\caption{A one qubit statevector $\kx{v}$ plotted on the unit circle.  The vector $\vec{v}$ forms the hypotenuse of a right triangle with sides of length $\abs{a}$ and $\abs{b}$.  Testing for the Z-basis states results in probability amplitudes of $\langle \,0\,|\,v\,\rangle = a$ and $\langle \,1\,|\,v\,\rangle = b$.}
	\label{fig:unitcircletrinoangle}
\end{figure}

\subsubsection{The X-basis states}
We have gotten comfortable with the qubit states which encode the classical bit states 0 and 1.  Yet if all we do with qubits is represent binary values, we are using a quantum bit to do exactly what a classical bit does.  We now demystify the math of one of the key features of quantum computing: \textit{superposition}.
A qubit is more powerful than a bit.  Informally, it can be 0, 1, or ``anything in-between''.  \textbf{Superposition} is this property of quantum states to encode information ``in-between'' states.  You might also hear people call a superposition of states, a \textit{mixture} of states.

A thought experiment about quantum superposition that you may have heard of before is Schr\"odinger's cat.  Suppose you have a closed box, and you know there is a cat in that box.  The question is, is that cat alive or dead?  The only way for you to tell is to open the box:
\noindent%
\begin{minipage}[t]{0.45\linewidth}
	\begin{frame}{}
		\animategraphics[controls,width=2in]{12}{images/OpeningBox/animation-}{0}{271}
	\end{frame}
\end{minipage}
More formally, you know that the cat in the box is in one of two states: alive or dead.
At the moment before you look into the box, your knowledge of the state of the cat is in superposition: there is some probability that the cat turns out to be alive, and some probability that the cat turns out to be dead.
The act of seeing the cat allows you to confirm which state of these two states the cat is in.

We will start with a special case of superposition that we will see often: that of \textit{equal superposition}.  Consider the state
\begin{equation}
	\tikzfig{ket+unnorm}
	\label{eq:ket+unnorm}
\end{equation}

It is the sum of $\kz0$ and $\kz1$:
\begin{equation}
	\tikzfig{ket+unnormsuperposition}
	\label{eq:ket+unnormsuperposition}
 \end{equation}

However, we will notice something goes wrong when we try to test the $\ket{+}$ state for itself:
\begin{equation}
	\tikzfig{braket++unnorm}
	\label{eq:braket++unnorm}
\end{equation}
We should have gotten the number 1, corresponding to probability 1, but instead we got a number greater than 1.
Somehow, we have calculated a probability of more than 1!
To fix this error, we need to introduce the concept of \textit{normalization}.
That means that we need to multiple our states by a constant factor so that if you test the state for itself, your test is successful 100\% of the time.
The $\kz0$ state is already normalized, as we saw in Equation~\ref{eq:braket00}.
To ensure the $\ket{+}$ state is normalized, we multiple by a factor of $\frac{1}{\sqrt{2}}$, which we will soon see fixes that issue.

The $\ket{+}$ state is one of the \textbf{X-basis} states.  Just as the Z-basis states lie on the Z axis of the Bloch sphere, the X-basis states lie on the X axis of the Bloch sphere.
We also introduce the other X-basis state, the $\ket{-}$ state.
\begin{align}
\label{eq:ket+}
&\tikzfig{ket+}\\
&\tikzfig{ket-}
\label{eq:ket-}
\end{align}

Like the $\kz0$ and $\kz1$ states, the $\kx+$ and $\kx-$ states can also be plotted on the unit circle:
\begin{figure}[H]
	\ctikzfig{unitcircle+-}
	\caption{$\kx+$ and $\kx-$ are plotted here on the unit circle.  This is just directly plotting their statevectors in 2D.}
	\label{fig:unitcirclexbasis}
\end{figure}

Perhaps you can guess what happens when given an X-basis state, you test for an X-basis state. Hint: it's the same as what happened with the Z-basis states in Equations~\ref{eq:braket00}~to~\ref{eq:braket11}.\nopagebreak
\begin{align}
	&\tikzfig{braket++}\\
	&\tikzfig{braket--}\\
	&\tikzfig{braket+-}\\
	&\tikzfig{braket-+}
\end{align}

On the Bloch sphere, they are on the positive and negative x-axis:
\begin{figure}[H]
	\ctikzfig{bloch+-}
	\caption{$\kx+$ and $\kx-$ are plotted here on the Bloch sphere.}
\end{figure}

You can think of the X-basis states as being exactly ``halfway in-between'' the Z-basis states.  Indeed, on the Bloch sphere, $\kz0$ and $\kz1$ are respectively on the north and south poles, while $\kx+$ and $\kx-$ are on the equator:
\begin{figure}[H]
	\ctikzfig{bloch+-wrt01}
	\caption{All states ``halfway in-between'' $\kz0$ and $\kz1$, such as $\kx+$ and $\kx-$, lie on the equator of the Bloch sphere.}
\end{figure}

In other words, the X-basis states are both \textbf{superpositions}, i.e. a complex linear combination, of the Z-basis states:
\begin{align}
\ket{+} &= \frac{1}{\sqrt{2}} (\kz0 + \kz1) \label{eq:kp01} \\
\ket{-} &= \frac{1}{\sqrt{2}} (\kz0 - \kz1) \label{eq:km01} \\
\end{align}
Nicely, the Z-basis states are in turn both superpositions of the X-basis states:
\begin{align}
\kz0 &= \frac{1}{\sqrt{2}} (\ket{+} + \ket{-}) \label{eq:k0pm} \\
\kz1 &= \frac{1}{\sqrt{2}} (\ket{+} - \ket{-}) \label{eq:k1pm}
\end{align}

Furthermore, Equations~\ref{eq:kp01}~to~\ref{eq:k1pm} above are \textit{uniform} superpositions --- each probability amplitude (i.e. coefficient) has the same magnitude of $\frac{1}{\sqrt{2}}$.
What this means is that the inner product of an X-basis state with a Z-basis state has magnitude $\frac{1}{\sqrt{2}}$:
\begin{align}
&\tikzfig{braket0+} \label{eq:braket0+} \\
&\tikzfig{braket1+}\\
&\tikzfig{braket0-}\\
&\tikzfig{braket1-} \label{eq:braket1-}
\end{align}
As we learned in Equation \ref{eq:braketprob}, the norm-squared of the probability amplitude is the probability you observe the outcome you're testing for.    Let's see this through an example.

\begin{example}[]
\label{ex:pr1m}
If your state is $\kx-$, and you test for $\kz1$, what is the probability you observe $\kz1$?

\textnormal{From Equation \ref{eq:braketprob}, we know that the probability of observing $\kz1$ when the state is $\kx-$ is $\abs{\langle\,1,\,|-\rangle}^2$.  In Equation \ref{eq:braket1-}, we found that $\langle\,1,\,|-\rangle = \texttt{-}\frac{1}{\sqrt{2}}$.  Therefore, the probability is $\abs{\langle\,1,\,|-\rangle}^2 = \frac{1}{2}$.}
\end{example}

You'll find that if you test for $\kz0$ when the state is $\kx-$, the probability is also $\frac{1}{2}$.  We've now arrived at the physical meaning of why we say that the X-basis states are ``halfway in-between'' the Z-basis states!  This leads us to the very important of quantum measurement...

\subsection{Quantum Measurement}
So far, we have talked about the mathematical description of the Z- and X- basis qubit states.  Now, let's talk about what is going on physically.
All around us are ``quantum states''.  You are made up of perhaps an octillion ($10^{27}$) molecules.  At any time, each molecule has its own quantum state.  However, in our macroscopic (at least compared to the length scale of individual molecules) world, we simply observe the collection of those molecules --- you!

Quantum effects only become relevant at really tiny length scales.  The size of today's transistors is just about small enough that quantum effects come into play.
\textit{Classical mechanics} is sufficient to describe most of physics on the length scale of us humans.  We need \textit{quantum mechanics} to describe physics on the length scale of atoms and molecules.

\subsubsection{The First Quantum Measurement Experiment}
To explore quantum measurement, we'll start with one of the earliest experiments in the history of quantum physics: the Stern-Gerlach experiment~\cite{Gerlach_Stern_1922}.  In fact, it was the first experiment where separate quantum states were directly observed!

Otto Stern designed this experiment, which Walther Gerlach carried out, where silver atoms were sent through an inhomogenous (different strength at different points in space) magnetic field and then hit a detector screen.  What happened, was that half of the atoms were deflected up, and half of the atoms were deflected down.  Interestingly, none of the atoms were observed at the height in-between.  This suggested that each silver atom had as an intrinsic property specifying which of the two directions it would be deflected in this experiment.  This property is \textbf{quantized} because when it is observed, its possible values are discrete rather than a continuous distribution.  If the atoms were instead spinning magnetic dipoles, they would be deflected by the magnetic field in a direction according to their spin, although the physics are different.  Due to this analogy, this quantized value of the atom is called \textit{spin}.

Due to the magnetic field (say it's oriented so its north pole is in the $+$z direction), atoms in a spin up quantum state would be deflected one way (up), and atoms in a spin down quantum state would be deflected the opposite way (down).

Up to now, given a qubit state, we have computed the probabilities of observing a certain outcome that we are testing for.  We will now learn about \textbf{orthonormal basis (ONB) measurement} --- a type of \textbf{quantum measurement} in which you observe exactly one of the outcomes in your chosen orthonormal basis of quantum states.  This is the type of quantum measurement you will use the most as a quantum computer scientist.  This is also the type of measurement done by the inhomogenous magnetic field in the Stern and Gerlach experiment.

When you perform an ONB measurement, you are actually simultaneously testing for all of the states in your ONB.  You can only observe one of those states, which is your measurement outcome.  The probability of you observing each outcome is exactly as how we have been computing so far: taking the norm-squared of the braket between your test (one of the states in your orthonormal basis) and your quantum state.

After your ONB measurement, \textit{your state becomes the one that was your measurement outcome}.  Doesn't matter if your state was not one of the ones in your ONB --- if that case, the act of performing quantum measurement changes the very state you are measuring.

At first, this may seem counterintuitive to our macroscopic world.  If you hold a ruler to find the position of a pin, you wouldn't expect the ruler to change where the pin is.  However, just to see the pin, you need to shine light on it.  Light is made up of photons which have momentum.  This momentum does nothing, as far as our eye can tell, to a massive (compared to the photon) object like the pin, but if it was instead a much smaller object with size comparable to that of photons, the momentum could be absorbed by it.  Therefore, your act of trying to see the pin can change the state of the pin.
%%% need to refine this explanation, create a ``collapse'' image, and create a unit circle trig image

As we saw from Example \ref{ex:pr1m}, the Z- and X- bases have the property that when measured in the other of the two bases, the probability of any measurement outcome is uniformly $\frac{1}{2}$.  For this reason, the Z- and X- bases are called \textit{mutually unbiased bases} with respect to each other.  We've now learned enough about mathematically describing quantum two-state systems to combine that understanding with what Stern and Gerlach observed.

\newpage
\begin{example}[Z-measurement then Z-measurement] \label{example:sterngerlachzz}
Stern and Gerlach observed that each silver atom passing through their inhomogenous magnetic field in the z direction had a $\frac{1}{2}$ chance of being deflected upwards ($+$z direction), and a $\frac{1}{2}$ chance of being deflected downwards ($-$z direction).  They then took each silver atom that was deflected upwards, and sent that through another inhomogenous magnetic field in the z direction.  This second time, all the atoms were deflected upwards --- why?

\begin{figure}[H]
	\ctikzfig{sterngerlachzz}
	\caption{This is what Stern and Gerlach saw when they sent a beam of silver atoms through the experimental setup of Example \ref{example:sterngerlachzz}.}
\end{figure}

\textnormal{All of the atoms deflected upwards by the first field (which was in the z-direction) were in the $z_+$ (spin up with respect to the z-axis) state, which we'll represent as the $\kz0$ state because the $\kz0$ state points in the $+$z direction on the Bloch sphere.  After those $z_+$ atoms traversed the second field (which was also in the z-direction), the probability of observing $z_+$ was
\begin{equation}
	\label{eq:prob00}
	\text{Pr}(\,0\,|\,0\,) = \abs{\langle\,0\,|\,0\,\rangle}^2
\end{equation}
From Equation \ref{eq:braket00}, we know that $\langle\,0\,|\,0\,\rangle$ is 1.  Therefore, all atoms that were deflected upwards after the first field, were also deflected upwards after the second field.}

\textnormal{Following this logic, we expect that any number of Z-measurements done thereafter would continue to yield the $z_+$ state.}
\end{example}

\newpage
\begin{example}[Z-measurement then X-measurement] \label{example:sterngerlachzx}
	Stern and Gerlach observed that each silver atom passing through their inhomogenous magnetic field in the z direction had a $\frac{1}{2}$ chance of being deflected upwards ($+$z direction), and a $\frac{1}{2}$ chance of being deflected downwards ($-$z direction).  They then took each silver atom that was deflected upwards, and sent that through another inhomogenous magnetic field, this time in the x direction.  This second time, $\frac{1}{2}$ the atoms were deflected in the $+$x direction and $\frac{1}{2}$ the atoms were deflected in the $-$x direction --- why?
	
	\begin{figure}[H]
		\ctikzfig{sterngerlachzx}
		\caption{This is what Stern and Gerlach saw when they sent a beam of silver atoms through the experimental setup of Example \ref{example:sterngerlachzx}.}
	\end{figure}

	\textnormal{Again, we use the $\kz0$ state to represent $z_+$, all atoms deflected upwards by the first field.  The $\kx+$ and $\kx-$ states are suitable to represent $x_+$ and $x_-$, the state of all atoms after the x-aligned magnetic field, because these states point in the $+x$ and $-x$ directions on the Bloch sphere.	After those $z_+$ atoms traversed the second field (in the x-direction), the probability of observing $x_+$ was
	\begin{equation}
		\text{Pr}(x_+|z_+) = \text{Pr}(+|\,0\,) = \abs{\langle+|\,0\,\rangle}^2
	\end{equation}
	and the probability of observing $x_-$ was
	\begin{equation}
		\text{Pr}(x_-|z_+) = \text{Pr}(-|\,0\,) = \abs{\langle-|\,0\,\rangle}^2
	\end{equation}
	From Equation \ref{eq:braket0+}, we know that $\langle+|\,0\,\rangle = \conj{\langle\,0\,|+\rangle} = \conj{\frac{1}{\sqrt{2}}} = \frac{1}{\sqrt{2}}$.  Likewise, $\langle-|\,0\,\rangle = \frac{1}{\sqrt{2}}$.  Therefore, all atoms that were deflected upwards after the first field, had a 50-50 chance of being deflected left or right after the second field.}
\end{example}

\newpage
\begin{example}[Z-measurement then X-measurement then Z-measurement] \label{example:sterngerlachzxz}
	After their setup in Example~\ref{example:sterngerlachzx}, Stern and Gerlach sent the $x_+$ silver atoms through one more z-aligned inhomogenous magnetic field.  They were surprised at what they saw.  What did they see?
	
	\begin{figure}[H]
		\ctikzfig{sterngerlachzxz}
		\caption{This is what Stern and Gerlach saw when they sent a beam of silver atoms through the experimental setup of Example \ref{example:sterngerlachzxz}.}
	\end{figure}

	\textnormal{At the end of Example \ref{example:sterngerlachzx}, the state was $x_+$, which we worked out is the $\kx+$ state.  After those $x_+$ atoms traversed the third field (in the z-direction), the probability of observing $z_+$ was
	\begin{equation}
		\text{Pr}(z_+|x_+) = \text{Pr}(\,0\,|+) = \abs{\langle\,0\,|+\rangle}^2
	\end{equation}
	and the probability of observing $z_-$ was
	\begin{equation}
		\text{Pr}(z_-|x_+) = \text{Pr}(\,1\,|+) = \abs{\langle\,1\,|+\rangle}^2
	\end{equation}
	From Equation~\ref{eq:braket0+}, we know that $\langle\,0\,|+\rangle = \frac{1}{\sqrt{2}}$.  Likewise, $\langle\,1\,|+\rangle = \frac{1}{\sqrt{2}}$.  Therefore, all atoms that were in the $\kx+$ state after the second field, had a 50-50 chance of being deflected up or down by the third field.  Therefore, the reason for Stern and Gerlach's surprise was that although the second of two consecutive Z-measurements yielded all $\kz0$ as we saw in Example \ref{example:sterngerlachzz}, adding an X-measurement in-between the Z-measurements changed that to half $\kz0$ and half $\kz1$.}
\end{example}

\newpage
\subsection{The pure qubit state, in general}
So far we have seen several examples of one-qubit states depicted on the unit circle and the Bloch sphere.  What do you need to depict any one-qubit state in general?

\subsubsection{Statevectors on the unit circle}
Any vector $\kx{v}$ on the unit circle by definition has magnitude (length) 1.
Its general form is
\begin{equation}
	\label{eq:onequbitpurerealform}
	\tikzfig{ketv}
\end{equation}
where $a$ and $b$ are real numbers.
When you perform a Z-basis measurement on a qubit whose statevector is of this form, according to Equation \ref{eq:braketprob}, the probability your outcome is $\kz0$ is
\begin{align}
	\text{Pr}(\,0\,|\,v\,) &= \abs{\langle \,0\,|\,v\,\rangle}^2\\
	&= \abs{\bz0 \text{\large(}a\kz0 + b\kz1\text{\large)}}^2\\
	&= \abs{a\,\langle \,0\,|\,0\,\rangle + b\,\langle \,0\,|\,1\,\rangle}^2\\
	&= \abs{a + 0}^2\\
	&= a^2
\end{align}
Likewise, the probability your outcome is $\kz1$ is $b^2$.  Since the only possible outcomes are $\kz0$ and $\kz1$, probability is conserved:
\begin{equation}
	a^2 + b^2 = 1
\end{equation}
Let's review how we draw this geometrically, as we did in Figure~\ref{fig:unitcircletrinoangle} back when we first introduced probability amplitudes.  It helps to draw a right triangle where the hypotenuse is $\kx{v}$, and the sides are parallel with $\kz0$ and $\kz1$.
Hence when $a$ and $b$ are real numbers, it is convenient to remember that the probabilities working out is simply the Pythagorean theorem:
\begin{equation}
	a^2 + b^2 = c^2
	\label{eq:pythagorean}
\end{equation}
where $a$ and $b$ are sides of the right triangle and $c$ is the hypotenuse.  In our case of a normalized vector on the unit circle, it has to have length 1, i.e. $c = 1$.
\begin{figure}[H]
	\ctikzfig{unitcircletriangle}
	\caption{A one qubit statevector $\kx{v}$ of the form $a\kz0 + b\kz1$, where $a$ and $b$ are real numbers, plotted on the unit circle.  The vector $\vec{v}$ forms the hypotenuse of a right triangle with sides of length $\abs{a}$ and $\abs{b}$.  The $a$ and $b$ shown in this figure are positive, but they can be any numbers from $-1$ to $1$ inclusive as long as they satisfy Equation~\ref{eq:pythagorean}, meaning they are on the unit circle.}
	\label{fig:unitcircletriangle}
\end{figure}


\subsubsection{Statevectors on the Bloch sphere}
The unit circle is not sufficient for our purposes.  That is because in general, a pure one qubit statevector is of the form
\begin{equation}
	\label{eq:onequbitpuregenform}
	\tikzfig{ketpsi}
\end{equation}
where $\alpha$ and $\beta$ are complex numbers.
Hence compared to Equation \ref{eq:onequbitpurerealform}, what's new is that coefficients can have imaginary components.  We celebrate this by chopping off the left corner of the triangle in our diagrams.  This will allow us to pictorially represent some key properties of complex vectors, as we will explore in the next section.

We mentioned earlier that going from the unit circle to the Bloch sphere, you double the angles.  We can see this by looking at the slice of the Bloch sphere where the unit circle lives, outlined as a black circle in Figure~\ref{fig:unitcircleinbloch}.
Plotting the same statevector, the angle $\theta$ on the Bloch sphere in Figure~\ref{fig:unitcircletriangle} is twice the angle $\Theta$ on the unit circle in Figure \ref{fig:unitcircleinbloch}, i.e. $\theta = 2 \Theta$.

We can always plot a statevector with real coefficients on the Bloch sphere in three steps:
\begin{enumerate}
	\item Find the angle $\Theta = \text{arctan}(\frac{b}{a})$
	\item Double that angle to get $\theta = 2 \Theta$
	\item Starting from the $+z$ axis (where $\kz0$ is), rotate an angle of $\theta$ along this slice of the Bloch sphere where the unit circle lives
\end{enumerate}

\begin{figure}[H]
	\ctikzfig{unitcircleinbloch}
	\caption{\textbf{Left:} A pure one qubit statevector $\kx{\psi}$ has the general form $\alpha\kz0 + \beta\kz1$, where $\alpha$ and $\beta$ are complex numbers.  Here, $\kx{\psi}$ is plotted on the Bloch sphere for the case where both $\alpha$ and $\beta$ are real numbers, and thus $\kx{\psi}$ must be in the XZ plane of the Bloch sphere, and lie on the circle outlined here in black.  \textbf{Right:} The unit circle plotted on the 2D real plane, as plotted in Figure~\ref{fig:unitcircletriangle}.}
	\label{fig:unitcircleinbloch}
\end{figure}
So if vectors on the Bloch sphere whose coefficients are real numbers lie on that circle, what about the rest of the sphere?
The rest of the sphere is where the coefficients have imaginary components.
Before we talk about the general form of any vector on the Bloch sphere, let us first get comfortable with probability amplitudes being complex numbers.

Up until now, to obtain the test corresponding to a state, all we had to do was take the matrix transpose of the ket column vector to get the bra row vector.  That has been correct so far because we have been dealing just with real numbers.  In general, when the statevectors can have complex coefficients, we need to take the \textit{conjugate transpose}\footnote{As a refresher, this means to take the transpose where you also replace each number by its complex conjugate.  This way, when all the numbers are real, the conjugate transpose and transpose operations are identical.} of the ket to get the bra, and the conjugate transpose of the bra to get the ket.

In the following example, we will introduce how we can perform transformations on our diagrams which correspond to transformations on our matrices.

\newpage
% \begin{example}[Y-basis states]
	What are the statevectors and diagrams corresponding to the complex conjugation, transpose, and conjugate transpose of $\kx{+i}$ and $\kx{-i}$, the Y-basis states introduced below?

	\textnormal{While we have seen the Z- and X- basis states in action, we have yet to do anything with the y axis of the Bloch sphere.
	The $+$y and $-$y axes respectively define two Y-basis states:
	\begin{align}
		\label{fig:ket+i}
		\tikzfig{ket+i}\\
		\label{fig:ket-i}
		\tikzfig{ket-i}
	\end{align}
	It doesn't make sense to visualize this on the unit circle, because in the real 2D plane we don't have an intuitive way of plotting complex numbers.
	On the Bloch sphere, they are simply the states corresponding to the $+$y and $-$y axes.
	}
	\begin{figure}
		\ctikzfig{bloch+i-i}
		\caption{$\kx{+i}$ and $\kx{-i}$ are plotted here on the Bloch sphere.}
	\end{figure}

	Complex conjugation:

	\textnormal{The complex conjugation of a diagram is its horizontal reflection.  Taking the complex conjugate of each element of $\kx{+i}$ and $\kx{-i}$ respectively, we get
	\begin{align}
		\tikzfig{ket+iconj}\\
		\tikzfig{ket-iconj}
	\end{align}
	}

	Transpose:

	\textnormal{The transpose of a diagram is its $180^{\degree}$ rotation.  Taking the transpose of $\kx{+i}$ and $\kx{-i}$ respectively, we get
	\begin{align}
		\tikzfig{ket+itranspose}\\
		\tikzfig{ket-itranspose}
	\end{align}
	}

	Conjugate transpose:

	\textnormal{The conjugate transpose\footnote{In some contexts, the word \textit{adjoint} is used interchangeably with conjugate transpose.} of a diagram is its horizontal reflection followed by $180^{\degree}$ rotation, or equivalently its $180^{\degree}$ rotation followed by horizontal reflection.  Taking the conjugate transpose of $\kx{+i}$ and $\kx{-i}$ respectively, we get their bra statevectors
	\begin{align}
		\tikzfig{bra+i}\\
		\tikzfig{bra-i}
	\end{align}
	This is consistent, because both taking the conjugate and then the transpose, and taking the transpose then the conjugate, yield the conjugate transpose.
	}
% \end{example}
In the above example, we put to use for the first time the distinction of which side of our bra and ket triangles we ``cut off''.
For the flowchart below, we consider an arbitrary qubit state $\psi$, but these three transformations can be done to any diagram.
Here we are reading our diagrams from bottom to top\footnote{There are other conventions, such as top to bottom, or left to right.  We will later switch to reading left to right, so we can translate between ZX diagrams and quantum circuits.}.
For an arbitrary qubit state $\psi$, we get the diagram of its complex conjugate by reflecting horizontally.
Likewise, we get the diagram of its adjoint (a.k.a. conjugate transpose) by reflecting vertically.
Finally, we get the diagram of its transpose by rotating by $180^{\degree}$.
\begin{figure}[H]
	\label{fig:conjugateandtransposestates}
	\ctikzfig{conjugateandtransposestates}
	\caption{Diagrammatically, we draw the complex conjugate, conjugate transpose, and transpose of any quantum state by respectively reflecting horizontally, reflecting vertically, and rotating $180^{\degree}$.}
\end{figure}

Whenever a quantum state has the special property of being self-conjugate --- equal to its own complex conjugate --- we can let its diagram simply be a triangle, as we did earlier for the $Z$ and $X$ basis states.
Looking back at Equations \ref{eq:ket0}, \ref{eq:ket1}, \ref{eq:ket+}, and \ref{eq:ket-}, we used a horizontally symmetric triangle as our diagrams for the Z- and X- basis states.  This is because all states in the ZX slice of the Bloch sphere have real number coefficients, and thus are self-conjugate.

Cheerfully, our toolbox now has all the X-, Y-, and Z- basis states.
\begin{figure}[H]
	\ctikzfig{blochxyzstates}
	\caption{The X-, Y-, and Z- basis states correspond to the x-, y-, and z- axes of the Bloch sphere.}
\end{figure}
Because each pure qubit state corresponds to a point on the surface of the Bloch sphere, we can use the xyz coordinates (i.e. the \textit{Cartesian coordinates}) of that point to specify the pure qubit state.

However, in quantum computing, we do not use xyz coordinates on the Bloch sphere.  Instead of using xyz coordinates, it is more convenient to use \textit{spherical coordinates} to locate a point on the surface of the Bloch sphere.  This is because when dealing with pure qubit states, we in fact only need two coordinates instead of three.  By doing so, we can relate between our statevector of two complex numbers and the three xyz coordinates.

In spherical coordinates, one of the two coordinates is the \textit{polar angle}.  This is the angle labelled $\theta$ in Figure~\ref{fig:unitcircleinbloch}.

For analogy, pretend our planet is a perfect sphere and we start with a vector from the center of the Earth to the North Pole.  When you rotate directly away from the North Pole in any direction (keeping the other end of the vector fixed at the center of the Earth) by the angle of the polar angle, you can end up anywhere in a circle on the sphere.  This consists of all points that have the same \textit{longitude} on the Earth, corresponding to that polar angle.
\begin{figure}[H]
	\ctikzfig{longitude}
	\caption{Perhaps the most familiar example is the Equator, the circle containing all points on the Earth's surface that have a polar angle of $90^{\degree}$.
	Other notable examples of circles containing all points on the Earth's surface with the same polar angle are the Arctic Circle, the Antarctic Circle, the Tropic of Capricorn, and the Tropic of Cancer.}
\end{figure}
To cover all possible such circles, such that each such circle corresponds to a unique polar angle, the polar angle is in the range $[0,\pi]$.

In spherical coordinates (on the surface of a sphere), the other coordinate is the \textit{azimuthal angle}.  Specifying the polar angle restricts the point to lie on one circle.  The azimuthal angle $\phi$, in the range of $[0,2\pi)$, specifies where the point is on that circle --- in the same way that the angle $\Theta$ in the range of $[0,2\pi)$ does in the circle in Figure~\ref{fig:unitcircletriangle}.
\begin{figure}[H]
	\centering
	\scalebox{\tikzscale}{\tikzfig{latitude}}
	\caption{Continuing the planet Earth analogy, the Prime Meridian corresponds to the semicircle containing all points for which the azimuthal angle is $0^{\degree}$.  To find where on Earth a spherical coordinate refers to, first find its longitude: the polar angle $\theta$ specifying a circle on the surface of the Earth.  Then, from where that circle intersects the Prime Meridian, go around that circle by its longitude, the azimuthal angle $\phi$, to find the point on Earth with that longitude and latitude.}
\end{figure}
It is worthwhile to mention that the convention amongst physicists is to label the polar angle by $\theta$ and the azimuthal angle by $\phi$.  It can be cause for confusion that the convention amongst mathematicians is the reverse: labelling the polar angle by $\phi$ and the azimuthal angle by $\theta$.

For the surface of a sphere we only need these two angles.  For any point in a real 3D coordinate system, there is a third coordinate $\rho$ which is the radius of the sphere that the point is on the surface of.  For our purposes, we are currently staying on the surface of the Bloch sphere (which has radius $1$), so we do not need to vary this radius coordinate yet.  When we eventually get to \textbf{mixed states}, these will correspond to points inside the volume of the Bloch sphere --- as opposed to pure states which correspond to points on the surface of the Bloch sphere.  The following note is to get an idea of mixed states.

\begin{note}
In this section we are learning about all possible single-qubit \textit{pure} quantum states --- on the surface of the Bloch sphere.
There exists one other type of single-qubit quantum state, called \textit{mixed} quantum states --- \textit{inside} the volume of the Bloch sphere.
Present-day quantum computers are \textit{noisy}\footnote{As of the time of writing this, we are in the day and age where quantum computers are not yet able to suppress noise enough to correct the errors that occur during quantum computation as they occur.  This is called the \textit{Noisy Intermediate-Scale Quantum} era, as first described by John Preskill in his paper at \url{https://quantum-journal.org/papers/q-2018-08-06-79/}.  In the future, quantum computers are predicted to be able to correct errors faster then they occur in quantum computation; this is called the \textit{fault-tolerant} era.}.  This noise causes the quantum states to have \textit{errors}.  As an analogy, imagine if you are on a call, and you have difficulty understanding what is said because the audio quality is too poor.

If we had a pure qubit state but it got affected by \textit{noise}, what happens is that in the Bloch sphere our state goes further towards the center as the \textit{coherence}, i.e. the ``sound quality'' with our analogy, gets worse.

The center of the Bloch sphere, where the $x$, $y$, and $z$ axes meet, is the \textit{maximally mixed state}.  In information theory, this is the quantum state with the least amount of information possible.  For instance regardless of whether you measure the maximally mixed state in the $x$ basis, the $y$ basis, or the $z$ basis, your measurement outcomes will be \textit{uniformly} random, i.e. the same probability for all possible outcomes.

Although we will not get to how to mathematically represent mixed states just yet, it is good for us to keep in mind that quantum theory allows us to \textit{mix} different quantum states in different proportions.
\end{note}

Like planet Earth, we specify a point on the surface of the Bloch sphere by its polar and its azimuthal angle.  The main difference between our planet Earth analogy and the Bloch sphere, is that while we live in a 3D world where all three axes are real number axes, on the Bloch sphere one of the three axes is a complex number axis.  You can see in Figure~\ref{fig:unitcircleinbloch} that the span of the $x$ and $z$ axes of the Bloch sphere is the slice where the coefficients of $\kz0$ and $\kz1$ are real numbers, while the $y$ axis is an imaginary axis such that the y-coordinate is nonzero when the coefficients of $\kz0$ and $\kz1$ are complex numbers.

Like how we plotted the ZX plane of the Bloch sphere in Figure~\ref{fig:unitcircleinbloch}, we will now plot the XY plane of the Bloch sphere.  This corresponds to the circle where the polar angle is $\pi/2$, like the equator of Earth, plotted as the unit circle in the complex plane.
\begin{figure}[H]
	\ctikzfig{unitcirclecomplexinbloch}
	\caption{\textbf{Left:} A pure one qubit state $\ket{\psi}$ has the general form $\alpha\kz0 + \beta\kz1$, where $\alpha$ and $\beta$ are complex numbers.  Here, $\ket{\psi}$ is plotted on the Bloch sphere for the case where $\alpha = 0$, and thus $\ket{\psi}$ must be in the XY plane of the Bloch sphere and thus lie on the circle outlined in black here.  \textbf{Right:} The unit circle plotted on the complex plane, because any complex number $\beta$ of magnitude~1 satisfies $\beta = e^{i \phi}$ for some angle $\phi$, called the \textit{complex phase} --- the angle counterclockwise around the origin of the complex plane.  Equivalently, $\beta = a + b i$ because of Euler's equation $e^{i \phi} = \text{cos}(\phi) + i \text{sin}(\phi)$, where $a = \text{cos}(\phi)$ and $b = \text{sin}(\phi)$ are real numbers.}
	\label{fig:unitcirclecomplexinbloch}
\end{figure}

We have now investigated two special cases of a pure qubit state.  First, in Figure~\ref{fig:unitcircleinbloch}, we explored the case where the azimuthal angle $\phi$ is either $0$ or $\pi$.  Then $\alpha$ and $\beta$ are both real, and so the qubit state must be in the intersection of the XZ plane and the surface of the Bloch sphere.

Second, in Figure~\ref{fig:unitcirclecomplexinbloch}, we explored the case where the polar angle $\theta = \pi/2$.  Then $\alpha = 0$, and $\beta$ is any complex number of magnitude 1, and so the qubit state must be in the intersection of the XY plane and the surface of the Bloch sphere.

We now proceed to generalize to any pure qubit state.

Any pure qubit state $\ket{\psi}$ can be expressed in the following form,
\begin{equation}
	\ket{\psi} = \text{cos}\left(\frac{\theta}{2}\right) \kz0 + e^{i \phi} \text{sin}\left(\frac{\theta}{2}\right) \kz1
	\label{eq:qubitinsphericalcoordinates}
\end{equation}
for polar angle $\theta$ in range $[0,\pi]$, and azimuthal angle $\phi$ in range $[0,2\pi)$.

There is a technicality here that is ignored in the above statement.  Note that in Equation~\ref{eq:qubitinsphericalcoordinates}, the coefficient of $\kz0$, $\text{cos}\left(\frac{\theta}{2}\right)$, is constrained to be a real number.  However, we previously allowed this coefficient of $\kz0$ to be any \textit{complex} number $\alpha$, so long as $\abs{\alpha}^2 + \abs{\beta}^2 = 1$ where
\begin{equation}
	\ket{\psi} = \alpha \kz0 + \beta \kz1
\end{equation}
How do we allow $\alpha$, the coefficient of $\kz0$, to have an imaginary component?

The answer is that we write the complex number $\alpha$ as
\begin{equation}
	\alpha = \mathrm{A} e^{i \gamma}
\end{equation}
where $\mathrm{A}$ and $\gamma$ are real numbers.
We can also write the complex number $\beta$, the coefficient of $\kz1$, as
\begin{equation}
	\beta = \mathrm{B} e^{i \eta}
\end{equation}
where $\mathrm{B}$ and $\eta$ are real numbers.
Then, we can write
\begin{align}
	\ket{\psi} &= \alpha \kz0 + \beta \kz1\\
	&= \mathrm{A} e^{i \gamma} \mkzero + \mathrm{B} e^{i \eta} \mkone\\
	&= e^{i \gamma} \left( \mathrm{A} \mkzero + e^{i (\eta - \gamma)} \mathrm{B} \mkone \right)
	\label{eq:qubitinsphericalcoordinateswithglobalphase}
\end{align}
Comparing Equations~\ref{eq:qubitinsphericalcoordinates}~and~\ref{eq:qubitinsphericalcoordinateswithglobalphase}, they differ by a factor of $e^{i \gamma}$ where
\begin{align}
	\mathrm{A} &= \text{cos}\left(\frac{\theta}{2}\right)\\
	\mathrm{B} &= \text{sin}\left(\frac{\theta}{2}\right)\\
	\phi &= \eta - \gamma
\end{align}
This factor of $e^{i \gamma}$ is called a \textbf{global phase}.  Another convention is to refer to $\gamma$ as the global phase.
We will now explain why, for practical purposes, we can ignore any global phase difference between two qubit states.
% The explanation of global phase in the Qiskit textbook is at https://qiskit.org/textbook/ch-states/representing-qubit-states.html

\begin{example}[Apollo's twin qubits]
	\label{ex:globalphase}
	Apollo and Artemis each have a qubit.  They know that one of the two qubits is in the state $\ket{\psi}$, although they don't know which one.  They also know that the other qubit is in the state $e^{i \gamma} \ket{\psi}$.  Is there a test they can do to figure out who has which qubit?

	\textnormal{How we learn information about a qubit's state is by testing it.  The ideal test would be one which can tell us decisively who has which qubit.  An ideal test $\bra{t_\text{ideal}}$ would be one that can distinguish between two states, $\ket{\psi}$ and $\ket{\phi}$, by satisfying either}
	\begin{align}
		\text{Pr}(t_\text{ideal} | \psi) &= 1\\
		\text{Pr}(t_\text{ideal} | \phi) &= 0
	\end{align}
	\textnormal{or}
	\begin{align}
		\text{Pr}(t_\text{ideal} | \psi) &= 0\\
		\text{Pr}(t_\text{ideal} | \phi) &= 1
	\end{align}

	\textnormal{Less than ideal, but still somewhat useful, would be a test that can make us more confident of whose qubit is in which state, satisfying either}
	\begin{align}
		\text{Pr}(t_\text{ideal} | \psi) &> \text{Pr}(t_\text{ideal} | \phi)\label{eq:idealpsi} > 0\\
		\intertext{\textnormal{or}}
		\text{Pr}(t_\text{ideal} | \psi) &< \text{Pr}(t_\text{ideal} | \phi)\label{eq:idealphi} < 1
	\end{align}
	\textnormal{In the case of Equation~\ref{eq:idealpsi}, if the test result is $t_\text{ideal}$, then they should conclude that the qubit they tested was in the $\psi$ state prior to their test.  In the case of Equation~\ref{eq:idealphi}, if the test result is $t_\text{ideal}$ they should conclude that their qubit was in the $\phi$ state.  Because the qubit's state after observing the test result $t_\text{ideal}$ becomes $\ket{t_\text{ideal}}$, further testing will not yield further information.}

	\textnormal{The two qubits that Apollo and Artemis have differ only by a global phase.  Therefore, regardless of what test $t$ they apply,}
	\begin{align}
		\text{Pr}(t | e^{i \gamma} \psi) &= \abs{\langle t | e^{i \gamma} \psi \rangle}^2\\
		&= \left(\abs{e^{i \gamma}}\abs{\langle t | \psi \rangle}\right)^2\\
		&= \abs{\langle t | \psi \rangle}^2\\
		&= \text{Pr}( t | \psi)
	\end{align}
	\textnormal{No matter the test that Apollo and Artemis use, whether the test succeeded or not does not give us any information on which of the two qubits was tested, because the likelihood that the test was successful is unrelated to which of the two qubits was tested.  Therefore, there is no possible test that they can do to tell apart their two qubits, with any confidence that is better than randomly guessing.}
\end{example}
In the above example, we see why any global phase has to be of the form $e^{i \gamma}$ for some real number $\gamma$.  A global phase cannot be just any complex number --- it must be a complex number of magnitude 1.  This is necessary for the probabilities in the above example to be sensible.

To state more accurately, each pure qubit state up to a global phase corresponds to a point on the surface of the Bloch sphere.  In Qiskit, when you visualize on the Bloch sphere a simulated quantum state (and thus know the global phase), the global phase information is visualized as a color in a continuous color wheel.

That's all for now, folks!
To get a taste of what we will learn next, check out how quantum gates transform a qubit state in the interactive Bloch sphere demo by James Weaver at \url{https://javafxpert.github.io/grok-bloch/}.

\section{Building a quantum circuit}

\subsection{Quantum gates, Part 1: Paulis}
In this section, we will meet all the single-qubit gates commonly encountered (which tend to have one-letter names).
We will also discuss what is a \textbf{group} mathematically, and how the $X$, $Y$, and $Z$ gates give us a group and all its nice properties.

\subsubsection{The I gate}
This gate is easy to remember because ``I'' stands for identity.
Its matrix is the identity matrix
\begin{equation}
	I = \begin{bmatrix}
		1 & 0\\
		0 & 1
	\end{bmatrix}
\end{equation}
For any pure qubit state $\ket{\psi}$, we can apply the I gate to it by multiplying its statevector by the identity matrix:
\begin{equation}
	I \ket{\psi} = \ket{\psi}
\end{equation}

Therefore, applying the I gate to the four states we have explored so far in bra-ket notation is:
\begin{align}
	I \kz0 = \kz0\\
	I \kz1 = \kz1\\
	I \kx+ = \kx+\\
	I \kx- = \kx-
\end{align}
Using bra-ket notation is more succinct than writing out the identity matrix and corresponding statevector in place of each respective letter ``I'' and ket.

No matter what the quantum state is, after applying the I gate on each qubit, the state will be unchanged.
Since the I gate performs the identity operation, the following diagrams are the same:
\begin{equation}
	\tikzfig{Igate}
\end{equation}
The absence of any state or test attached to these wires means that this equality between diagrams holds for any state and any test.

It may seem a bit silly to describe the gate which does nothing, but this was our first look at how a quantum gate can be expressed as a matrix.  We can now look at other gates and their respective matrices.  If we know the statevector of a qubit, when we multiply that vector by that matrix for a single-qubit gate, we obtain the qubit's statevector after applying that gate.

\subsubsection{The X gate}
When we previously learned about the X gate, also known as the NOT gate, it was to observe how it changes $\kz0$ to $\kz1$, and $\kz1$ to $\kz0$.
We can now learn how to apply it to any pure qubit state: multiplying by its matrix,
\begin{equation}
	X = \begin{bmatrix}
		0 & 1\\
		1 & 0
	\end{bmatrix}
\end{equation}
From the matrix definition, you can readily verify that
\begin{align}
	X \kz0 &= \begin{bmatrix}
		0 & 1\\
		1 & 0
	\end{bmatrix} \begin{bmatrix}
		1\\
		0
	\end{bmatrix}\\
	&= \begin{bmatrix}
		0\\
		1
	\end{bmatrix}\\
	&= \kz1
\end{align}
and
\begin{align}
	X \kz1 &= \begin{bmatrix}
		0 & 1\\
		1 & 0
	\end{bmatrix} \begin{bmatrix}
		0\\
		1
	\end{bmatrix}\\
	&= \begin{bmatrix}
		1\\
		0
	\end{bmatrix}\\
	&= \kz0
\end{align}

\begin{example}[Applying the X gate]
	What is the resulting state when you apply the X gate to each of the X-basis states?

	\textnormal{When you apply the X gate to the $\kx+$ state, the resulting state is}
	\begin{equation}
		X \kx+ = \begin{bmatrix}
			0 & 1\\
			1 & 0
		\end{bmatrix} \cdot \frac{1}{\sqrt{2}}\begin{bmatrix}
			1\\
			1
		\end{bmatrix} = \frac{1}{\sqrt{2}}\begin{bmatrix}
			1\\
			1
		\end{bmatrix} = \kx+
	\end{equation}

	\textnormal{When you apply the X gate to the $\kx-$ state, the resulting state is}
	\begin{equation}
		X \kx- = \begin{bmatrix}
			0 & 1\\
			1 & 0
		\end{bmatrix} \cdot \frac{1}{\sqrt{2}}\begin{bmatrix}
			1\\
			-1
		\end{bmatrix} = \frac{1}{\sqrt{2}}\begin{bmatrix}
			-1\\
			1
		\end{bmatrix} = -\kx-
	\end{equation}
	\textnormal{The resulting state is $\kx-$, with a factor of $-1 = e^{i \pi}$.  Recall that this means we have a \textit{global phase} of $\pi$.  Thus, we can ignore this factor because if you have one qubit in the $\kx-$ state and another qubit in the $-\kx-$ state, it is impossible to distinguish between them.}

	\textnormal{Now with the knowledge that the X gate does not change either of the X-basis states, it makes more sense why they are called the X-basis states.  The X-basis statevectors are \textit{eigenvectors} of the X gate matrix.  Like the Z-basis states, their statevectors form an (orthonormal) basis for any pure qubit statevector --- you can express any pure qubit statevector as a particular linear combination of $\kx+$ and $\kx-$.}
\end{example}

Don't worry, we won't have to compute many more matrices by hand in this text.
The point of learning here the basics of how to compute the application of a gate to a statevector, is so that when we use the formalism of the ZX calculus, we can convince ourselves that we are still doing the correct computation, but without having to directly compute any matrices.

What does the $X$ gate operation look like on the unit circle?
It is simply a reflection about the dashed line that is $45^{\degree}$ from $\kz1$, which is halfway between $\kz0$ and $\kz1$.
\begin{figure}[H]
	\ctikzfig{unitcirclex}
\end{figure}
Because the $\kx+$ state is on this dashed line, applying the $X$ gate to it leaves it unchanged --- the $\kx+$ statevector is an eigenvector of the $X$ gate matrix, with eigenvalue $+1$.

We can also visualize that reflecting about this dashed line maps $\kz0$ and $\kz1$ to each other.
Further, it maps $\kx-$ to $-\kx-$, showing that $\kx-$ is an eigenstate of $X$ with eigenvalue $-1$.
\begin{figure}[H]
	\ctikzfig{unitcirclexex}
\end{figure}


\subsubsection{The Z gate}
While the X gate interchanges the Z-basis states $\kz0$ and $\kz1$, the Z gate interchanges the X-basis states $\kx+$ and $\kx-$.  The Z and X bases are mutually unbiased to each other, as we saw earlier, because any Z-basis state measured in the X-basis can have measurement outcome equally likely to be either of the X-basis states, and vice versa.
However, the relationship between the Z and X bases is more special than that: when we start learning about the ZX-calculus, we will see they have the property of \textit{strong complementarity}.
This will enable us to describe quantum computations in terms of Z and X rotations.  At the end of this section introducing single-qubit gates, we will learn about these rotation gates.

What does the Z gate do to arbitrary pure qubit states?
We compute this by multiplying the statevector by the matrix of the Z gate,
\begin{equation}
	Z = \begin{bmatrix}
		1 & 0\\
		0 & -1
	\end{bmatrix}
\end{equation}

From the matrix definition, you can readily verify that
\begin{align}
	Z \kx+ &= \begin{bmatrix}
		1 & 0\\
		0 & -1
	\end{bmatrix} \frac{1}{\sqrt{2}}\begin{bmatrix}
		1\\
		1
	\end{bmatrix}\\
	&= \frac{1}{\sqrt{2}}\begin{bmatrix}
		1\\
		-1
	\end{bmatrix}\\
	&= \kx-
\end{align}
and
\begin{align}
	Z \kx- &= \begin{bmatrix}
		1 & 0\\
		0 & -1
	\end{bmatrix} \frac{1}{\sqrt{2}}\begin{bmatrix}
		1\\
		-1
	\end{bmatrix}\\
	&= \frac{1}{\sqrt{2}}\begin{bmatrix}
		1\\
		1
	\end{bmatrix}\\
	&= \kx+
\end{align}

Likewise, you can verify by matrix multiplication that $Z \kz0 = \kz0$ and $Z \kz1 = -\kz1$, demonstrating that $\kz0$ and $\kz1$ are indeed the Z-basis states as they are eigenstates of $Z$ with eigenvalues $+1$ and $-1$, respectively.

To readily recall what the $Z$ gate does to these four states, we can have a picture in our head of the unit circle.
Here the $Z$ gate is simply reflecting about the vertical dashed line below.
\begin{figure}[H]
	\ctikzfig{unitcirclez}
\end{figure}
\begin{figure}[H]
	\ctikzfig{unitcirclezex}
\end{figure}

\subsubsection{The Y gate}
The final of the three Pauli gates is the Y gate.
To apply it to any pure qubit state, we multiply that state's statevector by the matrix of the Y gate,
\begin{equation}
	Y = \begin{bmatrix}
		0 & -i\\
		i & 0
	\end{bmatrix}
\end{equation}
You can verify that the eigenvectors of the Y gate are the statevectors for $\ket{+i}$ and $\ket{-i}$, the states on the y-axis of the Bloch sphere.

As for what $Y$ does to the other basis vectors: Up to a global phase, it sends $\kz0$ and $\kz1$ to each other and $\kx+$ and $\kx-$ to each other.

\subsubsection{The Pauli group}
We will now introduce the gates \{I, X, Y, Z\} as part of a \textit{group}.
You may be used to using the word ``group'' in casual conversation as a collection of multiple individual entities, but the word ``group'' here is referring to the mathematical definition of a group.

\begin{definition}[Group]
	\label{def:group}
	A \textit{group} is a set (i.e. a collection of elements which are unordered), along with a binary operation (i.e. has two inputs and one output) called the \textit{group operation}, satisfying all four conditions below:
	\begin{itemize}
		\item \textit{closure}: Applying the group operation to any two elements in the set, always outputs an element in the set.
		\item \textit{associativity}: Let's call the group operation $\cdot$.  For any three elements of the group $a$, $b$, and $c$: $a \cdot (b \cdot c) = (a \cdot b) \cdot c$.
		\item \textit{identity}: There is exactly one element of the set, where applying it with any element in the set (including with itself) via the group operation, always outputs that other element.
		\item \textit{inverse}: For every element in the set, there is an element in the set such that applying the group operation to both elements outputs the identity element.
	\end{itemize}
\end{definition}
Depending on the situation, sometimes closure is a given.

We use and encounter groups all the time.  After all, our computers store and compute data using binary arithmetic, which works because of the following group:
\begin{example}[Binary addition]
	Check that the two numbers $\{0,1\}$ with addition modulo 2 (denoted by $+$) as the group operation is a group.

	\textnormal{We check each of the following are satisfied:
	\begin{itemize}
		\item \textit{associativity}: is satisfied because addition is associative
		\item \textit{closure}: $0+0=0$, $0+1=1$, $1+0=1$, and $1+1=0$ modulo 2 are all in the set $\{0,1\}$.
		\item \textit{identity}: $0$ is the identity element, because $0+1=1+0=1$ and $0+0=0$ modulo 2
		\item \textit{inverse}: $0$ and $1$ are both self-inverse, because $0+0=0$ and $1+1=0$ modulo 2
	\end{itemize}
	}
\end{example}

As an exercise, you can verify that the integers over addition (with identity element $0$) and the integers over multiplication (with identity element $1$) are both groups.  These are two examples of groups that have infinitely many elements, yet satisfy the closure property.

We will see that we can group together operations on quantum computers too.  The following example, albeit a little silly, is a useful analogy for the group we are setting up to introduce, of which $I$, $X$, $Y$, and $Z$ are elements.

\begin{example}[Artificial gravity]
	\label{ex:groupfirstex}
	You are an astronaut in a room shaped like a cube, in outer space.  In the absence of gravity, you rely on your magnetic boots to stand on any one of the six sides of the room.  There are three magnetic fields, aligned to each of the two sides of the room opposite each other.  Show that by being able to flip the direction of each magnetic field, you can stand on any combination of three non-opposite sides of the room.
	
	\textnormal{The brute-force approach to this would be to list all possible combinations of directions the magnetic fields could be in, but that is neither fun nor efficient.  Instead, we will show that these three flip operations, plus the identity operation (of doing nothing), generate a group where the group operation is doing these flips in succession.}
	
	\textnormal{Let's call the three flip operations $X$, $Y$, and $Z$; and the identity operation $I$.  We are in a 3D space, where we can represent any position by a vector of length 3.  Therefore, any linear transformation of position can be fully described by a real 3 by 3 matrix.  Here the matrix for $I$ is the 3 by 3 identity matrix}
	\begin{equation*}
		\begin{bmatrix}
			1 & 0 & 0\\
			0 & 1 & 0\\
			0 & 0 & 1
		\end{bmatrix}
	\end{equation*}	
	\textnormal{and the matrix for each flip is the above matrix except exactly one of the 1's on the diagonal is replaced by -1.}
	
	\textnormal{Let's check the conditions necessary for our group:}

	\begin{itemize}
		\item \textit{closure}: \textnormal{Any combination of three non-opposite sides can be labelled by the corner of the cube that they share.  A cube has 8 corners, so there are 8 elements of our group.  Observe that $X \cdot Y = Y \cdot X = -Z = -I \cdot Z = Z \cdot -I$, and more generally, doing two different flips, is the same as doing the third flip and flipping all three at once.  This gives closure of the 8 elements $\{\pm I, \pm X, \pm Y, \pm Z\}$, where the symbol $\pm$ means that both the positive and negative of the operation are an element in the group.}
		\item \textit{associativity}: \textnormal{This is satisfied, because matrix multiplication is associative.}
		\item \textit{identity}: \textnormal{$I$ is the identity element, because multiplying the identity matrix before or after any matrix, is the other matrix.}
		\item \textit{inverse}: \textnormal{For each of the 8 elements, it and its inverse element have matrices that are multiples of -1 of each other.}
	\end{itemize}
\end{example}
Observe that the operations $\{I,X,Y,Z\}$ \textit{generate} the group in the above example.  This means that by continuing to apply the group operation to this generating set, and to the outputs of that, you can get all the elements in the group.

This example is interesting because there is an important connection between the group of 3 by 3 real rotation matrices (called \textbf{SO(3)}), and the group of 2 by 2 complex unitary matrices (called \textbf{SU(2)}).  The group in the above example is a subgroup (a group within a group) of \textbf{SO(3)}.  On the other hand, the Pauli group, which we are on the verge of introducing, is a subgroup of \textbf{SU(2)}.
This connection between groups is the underlying reason why we can visualize all single-qubit (unitary) gates (which have matrices in \textbf{SU(2)}), as 3D rotations on the Bloch sphere (which has matrices in \textbf{SO(3)}).

Before we talked about the 3 by 3 real matrices called $X$, $Y$, and $Z$; now, let's talk about the 2 by 2 complex unitary matrices called $X$, $Y$, and $Z$.  Notice that each of $X$, $Y$, and $Z$ send their own basis states to themselves (up to a global phase), and send the other two bases' basis states to the other basis state in that basis (also up to a global phase).
This property has a deeper significance, as it arises from them being part of a \textit{group} as in Definition~\ref{def:group}, called the \textbf{Pauli group}.
If we compare to Example~\ref{ex:groupfirstex} with the group of reflections in SO(3) (three real number dimensions), the Pauli group is like that but for SU(2) (two complex number dimensions).

The Pauli group consists of the elements $\{\pm I, \pm X, \pm Y, \pm Z, \pm iI, \pm iX, \pm iY, \pm iZ\}$, where the group operation is matrix multiplication.

The Pauli group is \textit{generated} by the Pauli matrices $X$, $Y$, and $Z$.  So let us first define what a generating set of a group is.
\begin{definition}[Generating set of a group]
	\label{def:generategroup}
	Say we have some group $G$ already.
	A subset of the elements of the group is called a \textit{generating set} if you can apply the group operation to them in succession, to arrive at all the other elements of the group.
\end{definition}

\begin{example}[X, Y, and Z generate the Pauli group]
	\label{ex:generatepauli}
	Starting with the X, Y, and Z matrices, by only multiplying their matrices together, generate the rest of the Pauli group.

	\textnormal{
	You can show, using matrix multiplication, that $iI = X Y Z$.
	Therefore, $-I = (X Y Z)^2$, $-iI = (X Y Z)^3$, and $I = (X Y Z)^4$.
	We can multiply $X$ by $iI$, $-I$, and $-iI$ to get $iX$, $-X$, and $-iX$.
	Do the same to $Y$ and $Z$.
	Therefore, the three matrices $X$, $Y$, and $Z$ --- called the Pauli matrices --- generate the Pauli group.
	}
\end{example}

\textit{Ta-da!}  All the useful properties of a group are now at our disposal for the Pauli matrices.
For instance, we now know that if we apply any sequence of gates where each gate is one of $\{X, Y, Z\}$, the overall gate is still in the Pauli group, due to the group property of \emph{closure}.
We now also know that if we want to do any of the 16 gates in the Pauli group, we can always do so as a sequence of $\{X, Y, Z\}$, because they are a \emph{generating set} of the Pauli group.

\begin{note}
To give some spoiler text: the big thing we are leading up to is the \textbf{Clifford group}.  This is the bigger group that the Pauli group is a subgroup of.  The Clifford group has a generating set of three gates: $\{H, S, CX\}$, two of which ($H$ and $S$) we will learn about in the rest of this section, and the $CX$ gate we will learn in the next section.  The Clifford group is very important in quantum computing because it is the group of all the quantum gates that you can efficiently simulate with a classical computer.  Therefore, to do quantum computations we cannot efficiently simulate with a classical computer, we need to add to a generating set of the Clifford group, at least one non-Clifford gate i.e. not in the Clifford group.
\end{note}

\subsubsection{Visualizing rotation gates on the Bloch sphere}
We will have more to say about the Pauli group later, but for now let us next look at the Bloch sphere which is where we visualize SU(2).
This allows us to directly visualize another way.  What if instead of thinking about the Pauli matrices as ``reflecting'' about some axis on the unit circle, we thought about it as ``rotating'' halfway around the Bloch sphere?

The $X$, $Y$, and $Z$ gates are rotations halfway around the Bloch sphere ($\pi$ radians) about the x-, y-, and z- axes respectively.

Then we should also be able to rotate by other angles --- anything in the range $[0,2\pi)$.
We can now define the \textbf{parametrized} versions of the $X$, $Y$, and $Z$ gate: let us call them the $X$, $Y$, and $Z$ rotation gates.
The word parametrized here means in the sense of functions, because these three gates each take in one parameter, which is the desired angle of rotation (on the Bloch sphere), and return the matrix of the gate.
\begin{figure}[H]
	\ctikzfig{blochrxyz}
\end{figure}
As you can see here, we always rotate in the direction of the \textit{right-hand rule}: Make a thumbs up with your right hand, rotated so your thumb in the positive direction of the axis of rotation.  The direction your fingers curl towards is the direction of rotation.

The right-hand rule is a convention often used in physics.  A notable example is electric current flowing in a wire, depicted below.
\begin{figure}[H]
    \centering
	\includegraphics[width=0.7\columnwidth]{images/magnetic-field-produced-by-current.pdf}
	\caption{If you point your right thumb in the direction the current $I$ is flowing, then the direction your fingers curl is the direction of the magnetic field $B$ induced by that current.}
\end{figure}

\newpage
\begin{example}[Z rotation on the Bloch sphere]
We want to rotate the blue statevector on the Bloch sphere below about the z-axis by an angle $\alpha$, i.e. visualize applying the $Z(\alpha)$ gate.

\textnormal{Here $\alpha$ is a real number in the range $[0,2\pi)$ --- if it a real number outside that range, we can take it modulo $2\pi$ because rotating a full circle (which is $2\pi$ radians) gets you back where you started.}

\textnormal{The right hand rule tells us which direction to rotate.  We want to rotate about the z-axis, so we make a thumbs up with our right hand, and then point our right thumb in the $+z$ direction.  The direction our fingers are now curling towards, is the direction in which we will rotate by $\alpha$ radians.}

\textnormal{In the figure below, this direction and the angle $\alpha$ are in light blue.  After the $Z(\alpha)$ gate, our new statevector is shown in black on the Bloch sphere below.}
\begin{figure}[H]
	\ctikzfig{blochrzrotate}
\end{figure}
\end{example}

The matrices of $X$, $Y$, and $Z$ rotation gates are like the complex (SU(2)) version of the standard 3D rotation matrices (in SO(3)) about the three axes.
The $Z(\alpha)$ gate has the matrix\footnote{in Qiskit the $Z(\alpha)$ gate definition is the same up to a global phase of $e^{i\alpha/2}$.}
\begin{equation}
	Z = \begin{bmatrix}
		1 & 0\\
		0 & e^{i\alpha}
	\end{bmatrix}
\end{equation}

There are some angles of $Z$ rotation that are special enough to deserve their own gate names.
We'll just define them here:
\begin{itemize}
	\item The $Z$ gate is simply the $Z(\pi)$ gate, thanks to Euler's identity: $e^{i\pi} = -1$.
	\item The $S$ gate \begin{equation}
		S = \begin{bmatrix}
			1 & 0\\
			0 & i
		\end{bmatrix}
	\end{equation} is another name for the $Z(\pi/2)$ gate, as $e^{i\pi/2} = i$.
	\item The $T$ gate is the $Z(\pi/4)$ gate.
\end{itemize}
It turns out that if you rewrite a quantum circuit to be in terms of just $Z$ and $X$ rotations, and all of their rotation angles are multiples of $\frac{\pi}{2}$, then the quantum circuit is efficiently simulable by a classical computer!

\newpage
\subsubsection{The H gate}
We can cover one more useful single-qubit gate: the $H$ gate, which is short for the \textit{Hadamard gate}.  Its matrix is
\begin{equation}
	H = \frac{1}{\sqrt{2}}\begin{bmatrix}
		1 & 1\\
		1 & -1
	\end{bmatrix}
\end{equation}

We can have the intuition that the $H$ gate swaps the $Z$ and $X$ bases.
It sends $\kz0$ and $\kx+$ to each other, and $\kz1$ and $\kx-$ to each other.

On the unit circle, it is reflection about the dashed line below.
\begin{figure}[H]
	\label{fig:Hgate}
	\ctikzfig{unitcirclehreflect}
\end{figure}

In the Bloch sphere below, the unit circle but with angles doubled is the light blue circle.
The light blue axis that is halfway between the z- and x- axes of that circle, is the axis you do a $\pi$ rotation about for the $H$ gate.
\begin{figure}[H]
	\ctikzfig{blochh}
\end{figure}

A cool fact about 3D rotations is that if we know how to do (parametrized) rotations about any two perpendicular axes, we can then decompose a rotation of any angle of any axis into smaller rotations about just those two axes.
A useful example of this is the \textbf{Euler decomposition} of the $H$ gate.  It means that we can decompose the $H$ gate into alternating $Z$ and $X$ rotations where the rotation angle is $\pm \pi/2$.

\begin{align}
	H &= e^{-\frac{i\pi}{4}} \; Z\left(\frac{\pi}{2}\right) \; X\left(\frac{\pi}{2}\right) \; Z\left(\frac{\pi}{2}\right)
	H &= e^{-\frac{i\pi}{4}} \; X\left(\frac{\pi}{2}\right) \; Z\left(\frac{\pi}{2}\right) \; X\left(\frac{\pi}{2}\right)
\end{align}
How to read these equations is: Each gate in the above equations, for instance the one with label $Z\left(\frac{\pi}{2}\right)$, has a matrix.
If you replace all the gate labels with their matrices, you can check that the $H$ gate matrix indeed equals the three matrices on the right hand side of either equation above, times a complex number $e^{-\frac{i\pi}{4}}$.  This complex number is a \textit{global phase}, as we have encountered earlier.  In this text we will keep track of these global phases in equations such as these in case you ever want to look them up.  With that said, it's convenient to keep in mind that for most purposes you can ignore them, because as we saw from Example~\ref{ex:globalphase} we cannot tell the difference between quantum systems that have the same state up to global phase anyway.

In this text, we may also drop the global phase factor where it is convenient to do so, and where it is less likely to be equations you may want to look up later (for instance within examples).  In those cases, a notation we may use is a doubly squiggly line, such as
\begin{align}
	H &\approx Z\left(\frac{\pi}{2}\right) \; X\left(\frac{\pi}{2}\right) \; Z\left(\frac{\pi}{2}\right)
	H &\approx X\left(\frac{\pi}{2}\right) \; Z\left(\frac{\pi}{2}\right) \; X\left(\frac{\pi}{2}\right)
\end{align}
which means that there is a global factor, i.e. one side of the equation is a complex number multiple of the other.

Back to the $H$ gate Euler decomposition.  We can see this visually on the Bloch sphere by comparing the two animations below\footnote{These animations are from \url{https://quantumcomputing.stackexchange.com/questions/18031/how-to-visualize-hadamard-gate-as-x-z-x-decomposition}}.
% description of the two animations goes here
\begin{figure}[H]
\noindent%
\begin{minipage}[t]{0.45\linewidth}
	\begin{frame}{}
		\animategraphics[controls,width=2in]{12}{images/HgateBlochrotations/animation-}{0}{120}
	\end{frame}\end{minipage}%
\hfill%
\begin{minipage}[t]{0.45\linewidth}
	\begin{frame}{}
		\animategraphics[controls,width=2in]{20}{images/HgateEulerBloch/animation-}{0}{200}
	\end{frame}
\end{minipage}
\caption{For ease of visualization, both of these animations first rotate the $\kz0$ state to an arbitrary other single-qubit state on the surface of the Bloch sphere --- this is the first two rotations which are respectively green and blue.  \textbf{Left:} The third and final rotation, colored gray, is the $H$ gate, which is a $\pi$ rotation about the axis that is halfway between the $x$ and $z$ axes, i.e. the $\frac{\kz0 + \kx+}{\sqrt{2}}$ axis.  \textbf{Right:} The last three rotations, colored green, blue, and green; are $\pi/2$ $X$, $Z$, and $X$ rotations respectively.  As expected, both of these animations end in the same point on the surface of the Bloch sphere.}
\end{figure}


\newpage
\section{Recipe for one-qubit quantum circuits}
If a quantum circuit were a cookbook recipe, it would have three ingredients: states, gates, and measurements.
How are we doing on meal prep?
\begin{itemize}
	\item We learned how to represent a pure qubit state as a ket vector.
	\item We got a sneak peek at our first quantum gates when we learned about how the X, Y, and Z gates are $\pi$ ($180^{\circ}$) rotations on the Bloch sphere.
	\item We learned about how we can explain the funky physics of quantum measurement thanks to the probabilities we get when we test our quantum states for our chosen basis.
\end{itemize}
To pre-heat the oven, let us create a free account at \url{https://quantum-computing.ibm.com/}.  Get excited!  We are about to create our first quantum circuit together and run it on a real quantum computer.
When you log in, launch the IBM Quantum Composer and make a new circuit.
First, your circuit needs a name that is not `Untitled circuit'.
\begin{figure}[H]
	\includegraphics[width=\columnwidth]{images/NewCircuit_IBMQuantumComposer.PNG}
\end{figure}
The main section of the page is where you will build your circuit.  We will start with one qubit at a time, so go ahead and move your cursor to the right, over each of the bottom two letter q's and click the bin icon that appears.

There should be one letter q left.  On the wire to its right, drag the \textit{measure} icon (the middlemost of the gray squares above).
\begin{figure}[H]
	\includegraphics[width=\columnwidth]{images/Measure_IBMQuantumComposer.PNG}
\end{figure}
You'll see the section at the bottom left change when you apply this measurement to your qubit.  Because each qubit is initialized in the $\kz0$ state by default, the simulated measurement probability of measuring $\kz0$ is $100\%$, while for $\kz1$ it is $0\%$.  This is as we expect from when we first calculated probability amplitudes in Equations~\ref{eq:braket00} and \ref{eq:braket01}, and found the probability in Equation~\ref{eq:prob00}.

Now we can try to do the same process of measuring, this time for the $\kz1$ state.  You may notice that although there is a gray icon above labelled $\kz0$ which is used to (re-)initialize a qubit to the $\kz0$ state, there is no icon labelled $\kz1$.  Instead, we will create it out of the operations we have.

See the target icon, which is the leftmost blue icon?  That is the X gate, a.k.a. the NOT gate.  Instead of a target, sometimes in quantum circuits it is drawn as a box on the wire with the letter X in it.
If you drag that X gate icon just left of where you dragged the measure icon, you will see the probabilities change from $100\%$ $\kz0$ to $100\%$ $\kz1$.
\begin{figure}[H]
	\includegraphics[width=\columnwidth]{images/ket1_IBMQuantumComposer.PNG}
	\label{fig:myfirstcircuit}
\end{figure}

Behold the very first quantum circuit we have built together!  It combines our three ingredients in a recipe:
\begin{enumerate}
	\item We start with our first ingredient, a quantum state.
	\item We apply to it one or more quantum gates.
	\item At the end, we measure our qubits.
\end{enumerate}
This is the ``recipe template'' for building any quantum circuit in the \textbf{circuit model}.  There are other models of quantum computation, but this is the most well-known and commonly used.  Circuit diagrams in the circuit model are typically drawn like they are here: each qubit is initialized to some state denoted by a ket, then gate(s) (drawn as boxes labelled by the letter(s) of the gate's name) are applied sequentially along its wire to its right, and finally the wire ends when a measurement is made.  One exception is that circuit diagrams are usually in black and white --- the colors added shown here are arbitrary; feel free to \href{https://medium.com/qiskit/learn-how-to-customize-the-appearance-of-your-qiskit-circuits-with-accessibility-in-mind-b9b59fc039f3}{customize the appearance of your circuits} once we begin coding.  Throughout this text, we will present circuit diagrams in black and white, to contrast with other types of diagrams for which different colors have different meanings.

As you can see, every time you drag-'n'-drop any operation, the code to your right hand side changes.  Above it, the two drop-down code options are OpenQASM and Qiskit.

\textit{OpenQASM} is short for open-source quantum assembly language.  It is an intermediate representation that quantum programs compile to.  While it is in this form, it is common to perform circuit optimization, which may take into consideration the capabilities of the hardware or simulation you are running on.  The open-source repository link for OpenQASM is at \url{https://github.com/QISKit/openqasm}.

\textit{Qiskit} is short for Quantum Information Science Kit.  It is the most widely used quantum programming language, perhaps more accurately, a software development kit based in Python.  The open-source repository link for Qiskit is at \url{https://github.com/QISKit/}.

Both OpenQASM and Qiskit are developed by IBM, which made waves when they were the first to release quantum computing hardware open-access on the cloud in 2017.  Since then, they have several dozen processors available on the cloud, and over one billion circuits run on them each day.

Also above the code in IBM Quantum Composer is a link to `Open in Quantum Lab'.  Go ahead and click on that to enter the \textit{IBM Quantum Lab}.  Here you can explore, in your browser, running Jupyter notebooks with Qiskit ready to use.  We will use it here so this guide is platform-independent.  For development purposes, it is a good idea to set up a local environment sooner or later; the quick start for installation is at the bottom of the \url{https://qiskit.org/overview/} webpage.
\begin{figure}[H]
	\includegraphics[width=\columnwidth]{images/HelloWorld_IBMQuantumLab.PNG}
\end{figure}

Let's first press the triangle above the Jupyter notebook to `Run the selected cells and advance'.
\begin{figure}[H]
	\includegraphics[width=\columnwidth]{images/HelloWorld_run_IBMQuantumLab.PNG}
\end{figure}
Now let us delete the first line and the last two lines.  Instead, let us add the line
\begin{lstlisting}[language=Python]
	circuit.draw()
\end{lstlisting}
at the end of the cell, and re-run.  You should see the previous circuit composer display changed to an image of a quantum circuit.
\begin{figure}[H]
	\includegraphics[width=\columnwidth]{images/HelloWorld-2_IBMQuantumLab.PNG}
\end{figure}

Something you may have noticed is that now, although our circuit has a measurement operation, we do not see the probabilities of all the measurement outcomes.  This is because the code so far creates a circuit, and we will need a few more lines to run this circuit.

We will run our circuits on a simulator so there is not a queue to wait in to run on physical hardware, and so we can learn what the circuits do in a noise-free environment.  Real quantum computers today are noisy, which means that they are prone to errors when performing computations.  This is why you may have heard the term \textit{Noisy Intermediate-Scale Quantum} (NISQ) to describe quantum computing today.  The expectation is that in the coming years, the noise will be low enough so that \textit{fault-tolerance} can be achieved at scale, so that quantum error correction can be performed to suppress these errors.  Therefore, the engineering challenge of scaling up quantum computers is just as much reducing noise, as increasing the number of qubits and operations between them.

To import the simulator, add `Aer' to our list of imports from Qiskit
\begin{lstlisting}[language=Python]
	from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, Aer
\end{lstlisting}
and re-run that cell.  Then, in the cell below that, run
\begin{lstlisting}[language=Python]
	backend = Aer.get_backend('qasm_simulator')
	job = backend.run(circuit)
	result = job.result()
	print(result.get_counts())
\end{lstlisting}

You should see the output in curly brackets.  This is the \textit{counts}, a dictionary in Python which stores measurement outcomes.  By default, it runs your circuit 1024 times.  How to interpret it, is that for each binary string key in the dictionary, it gives you the number of times for which that measurement outcome was observed.
\begin{figure}[H]
	\includegraphics[width=\columnwidth]{images/HelloWorld-4_IBMQuantumLab.PNG}
\end{figure}

Just so our experiments (the name for running all these simulations) will roughly correspond to our probabilities, we can change the number of times of our circuit is run, i.e. the number of \textit{shots}, from 1024 to 100.  Keep in mind that because these are randomized, they will likely not be the exact probabilities, but they will reasonably close.  Although we could see the exact statevector, for instance if we instead used the \textit{statevector simulator}, using the QASM simulator is more realistic because on a real quantum computer, the state cannot be observed except through measurement outcomes.
\begin{lstlisting}[language=Python]
	job = backend.run(circuit, shots=100)
\end{lstlisting}

We will now see the H gate in action.  As we saw before in Figure~\ref{fig:Hgate}, it maps the $\kz0$ and $\kx{+}$ states to each other, and the $\kz1$ and $\kx{-}$ states to each other.  In other words, it maps each Z-basis state to the corresponding X-basis state, and vice versa.
You can see through matrix multiplication that
\begin{equation}
	Z = H X H
\end{equation}
and
\begin{equation}
	X = H Z H
\end{equation}

It may seem rather cumbersome to multiply matrices each time we want to figure out what a sequence of gates is doing.  Not only is it unintuitive, but we will soon see that even with small numbers of qubits, the matrices get (exponentially) large, and therefore rapidly more computationally expensive to multiply.

Thankfully, we do not have to resign ourselves to the tedium of multiplying matrices to understand what our quantum circuits are doing.  We just need to build up our toolbox so that we can use the right tool for the job.  We have already learned about how to visualize qubit states on the unit circle and on the Bloch sphere, and how to compute the probabilities of each possible measurement outcome of a one-qubit circuit using matrix multiplication.  Now, we will convert these one-qubit circuit model diagrams into ZX-calculus diagrams.  Just like we did before with rewriting AND, OR, and NOT circuit diagrams to figure out what they are doing, we can rewrite ZX-calculus diagrams to figure out what they are doing.

\section{The ZX-calculus}
To help us develop intuition for the Z- and X- bases, we will learn how to read, draw, and make deductions using \textbf{ZX-calculus} diagrams.  The qubit ZX-calculus is a pictorial language in which you can reason about all of qubit quantum computation.  As we continue learning, we will see how convenient of a tool these diagrams are.  As with the circuit model, we choose the convention of drawing and reading these diagrams from left to right.

We have already met the $Z$ and $X$ gates.  But have you met them in color?\footnote{The ZX-calculus was originally also called the green-red calculus, because it was invented on a whiteboard with green and red markers.}  In this text we will use the colors light green and darker pink, as to be easily distinguishable for the red-green colorblind.  Rotations about the z-axis Bloch sphere are colored in green, whereas rotations around the x-axis of the Bloch sphere are colored in pink.  In the ZX-calculus, we draw $Z$ and $X$ rotation gates as green and pink dots, respectively; they have one input wire and output wire, like how we drew them in the circuit model.  We label the dot with the \textbf{phase}, which is the angle of rotation on the Bloch sphere.

\subsection{$Z$ and $X$ rotations in the ZX-calculus}
The $Z$ rotation gate is drawn in the ZX-calculus as
\begin{equation*}
	\tikzfig{zxZphase}
\end{equation*}
The phase $\alpha$, in radians (i.e. any number in the range $[0,2\pi)$ ), is the angle of rotation about the z-axis on the Bloch sphere.
In matrix form, the gate in terms of $\alpha$ is:
\begin{equation}
	Z(\alpha) = \begin{bmatrix}
		1 & 0\\
		0 & e^{i\alpha}
	\end{bmatrix}
\end{equation}
These are the Z rotation gates we saw before.  This gate takes in one parameter, the angle of rotation on the Bloch sphere, denoted here by the variable $\alpha$.

For the special case when $\alpha = 0$, no rotation occurs.  The gate is the identity gate $\mathbb{I}$ because its matrix is equal to the identity matrix.  By convention, we leave out the phase label when $\alpha = 0$.  This also applies whenever $\alpha$ is an integer multiple of $2\pi$, because whenever you go around in a circle a full rotation, you are back where you started.
\begin{equation}\label{eq:zxZI}
	\tikzfig{zxZI}	
\end{equation}
We'll use this two-headed squiggly arrow to mean when we are translating between circuit model and ZX-calculus diagrammatic notation for a given gate.
By the end of this section, it should be easy to tell whether a diagram is a circuit model diagram or a ZX-calculus diagram.

There are plenty of other special cases each interesting in their own way.  When $\alpha = \pi$, we have the $Z$ gate.  The reason why the $Z$ gate is the same gate as the $Z(\pi)$ gate, is that the $Z$ gate rotates exactly halfway ($\pi$ radians) around the z-axis of the Bloch sphere.  Therefore, the $Z$ gate in the ZX-calculus is drawn as
\begin{equation}
	\tikzfig{zxZ}
\end{equation}
where the right hand side of the equation is how the $Z$ gate is drawn in the circuit model.

Other special cases are the $S = Z(\frac{\pi}{2})$ gate
\begin{equation}
	\tikzfig{zxS}
\end{equation}
and the $T = Z(\frac{\pi}{4})$ gate.
\begin{equation}
	\tikzfig{zxT}
\end{equation}

In the opposite color, the $X$ rotation gate is drawn in the ZX-calculus as
\begin{equation*}
	\tikzfig{zxXphase}
\end{equation*}
The phase $\alpha$ is now the angle of rotation about the x-axis on the Bloch sphere.

We again have that $X(0) = \mathbb{I}$
\begin{equation}\label{eq:zxXI}
	\tikzfig{zxXI}	
\end{equation}
and the $X$ gate is the same as the $X(\pi)$ gate.
\begin{equation}
	\tikzfig{zxX}
\end{equation}

We know that the $\kz0$ and $\kz1$ states are the Z-basis states, while the $\kx+$ and $\kx-$ states are the X-basis states.
What do they look like in the ZX-calculus?

The Z-basis states and tests are
\begin{equation}
	\tikzfig{zxk0}
\end{equation}
and
\begin{equation}
	\tikzfig{zxk1}
\end{equation}

The X-basis states and tests are
\begin{equation}
	\tikzfig{zxk+}
\end{equation}
and
\begin{equation}
	\tikzfig{zxk-}
\end{equation}

In the next example, we will look into why they are drawn this way in the ZX-calculus.
This brings us to our first \emph{rewrite rule} in the ZX-calculus, which across the literature has been also named the \emph{fusion rule} or the \emph{spider rule}.
Let us first describe this rule informally.
\begin{zxrule}\label{zx:spider_fusion}
	Consider two same color dots with at least one wire between them.
	If all the wires between them are bare, the two dots can be \emph{fused} together to become a new dot of the same color.
	This new dot's phase is the sum of the two original dot's phases.
\end{zxrule}
While this description is about when we can fuse dots, because the diagrams we have before and after are mathematically equal to each other, we can apply this rule in the opposite direction too.
This means that whenever we have a dot, we can ``unfuse'' it into two dots connected by at least one wire each with the same color as the original dot, as long as the two new dots' phases add up to the original dot's phase.

This can seem a little abstract at the moment, so let us connect this with operations we can do with one qubit.
So far we have only talked about having only one wire connecting any two things in our ZX-calculus diagrams, so once we have multiple qubit circuits we will see situations where there are more than one wire between dots.
For now, let us draw what this rule looks like in the cases we have so far.  For a single qubit, there are four possible diagrams where there are two same color dots (with arbitrary phases $\alpha$ and $\beta$) connected by a wire.  We will present each of these four cases below, but whereever the definition involves ``at least one'' wire we will draw one wire, as we will later understand what it means to draw multiple wires.

The first case is a \emph{number}: any diagram with no inputs and no outputs.  We have seen diagrams of numbers several times before: whenever we applied a test to a state, what we got was a number which gives you (by taking the number's norm squared) the success probability of the test.
\begin{equation}
	\tikzfig{zxZfusion1qff}
\end{equation}

The second case is a \emph{state}: any diagram with no inputs and at least one output wire.
\begin{equation}
	\tikzfig{zxZfusion1qft}
\end{equation}

The third case is a \emph{test}: any diagram with at least one input wire and no outputs.
\begin{equation}
	\tikzfig{zxZfusion1qtf}
\end{equation}

The fourth and final case is a \emph{single-qubit gate}:
\begin{equation}
	\tikzfig{zxZfusion1qtt}
\end{equation}

The above rules still hold if the dots are instead all pink.

With this we can now see why Z and X gates and basis states are drawn as they are in the ZX-calculus.
While these diagrams are simple, they have a well-defined \textit{interpretation} --- given any ZX diagram, we can write down its meaning as a composition of matrices.
By the rule of the ZX-calculus, the four above equations are all correct, but if we weren't convinced, we can verify by direct computation.
\begin{example}
	Confirm the above equations for all four cases are correct.
	\soln \textnormal{Let's start with the fourth case:}
	\begin{equation}
		Z(\beta) Z(\alpha) = \begin{bmatrix}
			1 & 0\\
			0 & e^{i \beta}
		\end{bmatrix} \quad \begin{bmatrix}
			1 & 0\\
			0 & e^{i \alpha}
		\end{bmatrix} = \begin{bmatrix}
			1 & 0\\
			0 & e^{i (\alpha + \beta)}
		\end{bmatrix} = Z(\alpha + \beta)
	\end{equation}

	\textnormal{From here on, we just need to check the below three equations, for arbitrary phase $\gamma$:}
	\begin{align}
		\tikzfig{zxZfusion1qstate} &\leftrightsquigarrow Z(\gamma) \kx+ = \begin{bmatrix}
				1 & 0\\
				0 & e^{i \gamma}
			\end{bmatrix} \frac{1}{\sqrt{2}} \begin{bmatrix}
				1\\
				1
			\end{bmatrix} = \frac{1}{\sqrt{2}} \begin{bmatrix}
				1\\
				e^{i \gamma}
			\end{bmatrix}\\
		\tikzfig{zxZfusion1qtest} &\leftrightsquigarrow \bx+ Z(\gamma) = \frac{1}{\sqrt{2}} \begin{bmatrix}
				1 & 1
			\end{bmatrix} \begin{bmatrix}
				1 & 0\\
				0 & e^{i \gamma}
			\end{bmatrix} = \frac{1}{\sqrt{2}} \begin{bmatrix}
				1 & e^{i \gamma}
			\end{bmatrix}\\
		\tikzfig{zxZfusion1qstatetest} &\leftrightsquigarrow \bx+ Z(\gamma) \kx+ = \frac{1}{\sqrt{2}} \begin{bmatrix}
			1 & 1
		\end{bmatrix} \begin{bmatrix}
				1 & 0\\
				0 & e^{i \gamma}
			\end{bmatrix} \frac{1}{\sqrt{2}} \begin{bmatrix}
				1\\
				1
			\end{bmatrix} = \frac{1}{2} \left( 1 + e^{i \gamma} \right)
	\end{align}	

	\textnormal{Combining the above gives us the other three cases:}
	\begin{equation}
		\tikzfig{zxZfusion1qfffttf}
	\end{equation}
\end{example}

\newpage
\begin{example}[Applying Z and X gates to Z and X basis states]
Remember that $X \kz0 = \kz1$?  When we write this out in ZX-calculus, we get
\begin{equation}
	\tikzfig{zxXk0}
\end{equation}
Likewise, $Z \kx+ = \kx-$ becomes
\begin{equation}
	\tikzfig{zxZk+}
\end{equation}
It is simply a matter of ``fusing'' the two adjacent dots of the same color, adding up their rotation angles.
This also holds for showing $X \kz1 = \kz0$ and $Z \kz- = \kz+$, because $\pi + \pi = 2\pi$:
\begin{equation}
	\tikzfig{zxXk1}
\end{equation}
\begin{equation}
	\tikzfig{zxZk-}
\end{equation}
\end{example}

\subsection{Color changing in the ZX-calculus}
There are two main conventions that are used for drawing the $H$ gate in the ZX-calculus, which mean the same and are just for more convenient notation depending on the situation.
One convention is to use a small square to denote the $H$ gate.  In this text, to be accessible to colorblind readers, we will fill these squares with the color sky blue to be distinguishable from the green and pink colors in ZX diagrams; this is a departure from other texts where the convention is to fill these squares with the color yellow.
\begin{equation}
	\tikzfig{zxH}
\end{equation}

Another convention that can be used interchangeably, is to use instead make that entire wire sky blue.
Later we will see how ZX diagrams are graphs, and so wires are the edges between nodes in the graph.  Any wire with exactly one $H$ gate on it is called a Hadamard edge, as $H$ is short for Hadamard.
It looks like:
\begin{equation}
	\tikzfig{zxHedge}
\end{equation}

A neat thing about the $H$ gate is that if you do it twice in a row, it's as if you did nothing.
\begin{equation}
	\tikzfig{zxHH}
\end{equation}
This means that the $H$ gate is \textbf{self-inverse}.  This is special because most quantum gates do not have this property, i.e. the gate that is inverse to itself is not itself.

As we saw in the previous section, surrounding an $X$ gate on both sides by $H$ gates turns it into a $Z$ gate.
Likewise, surrounding a $Z$ gate on both sides by $H$ gates turns it into an $X$ gate.
This brings us to our first rewrite rule in the ZX-calculus: the \textit{color change} rule.
It is called that because we denote $Z$ rotation gates with the color green, and $X$ rotation gates with the color pink\footnote{The $H$ gate is the single-qubit Fourier transform between the $Z$ and $X$ bases.  Because we denote these two bases with different colors, changing between these two colors is an intuitive way to think about this Fourier transform.}.
For one-qubit $Z$ and $X$ rotation gates, we can draw the equation
\begin{equation}
	Z(\alpha) = H \; X(\alpha) \; H
\end{equation}
 in the circuit model as
\begin{equation}
	\tikzfig{circuitcolorchange}
\end{equation}
or in the ZX-calculus as
\begin{equation}\label{eq:zxcolorchange}
	\tikzfig{zxcolorchange}
\end{equation}

\begin{example}[]
	\label{ex:othercolorchange}
What happens if we put two $H$ gates on either side of a $Z(\alpha)$ gate?

Simplifying with our newest ZX-calculus rules:
\begin{equation}
	\tikzfig{zxothercolorchange}
\end{equation}
Thus, we have shown that $H Z(\alpha) H = X(\alpha)$.
Compare to Eq.~\eqref{eq:zxcolorchange}, which is the same rule but with the colors swapped.
\end{example}

Now we see why we can think of the $H$ gate as a `color change box'.  This color change rule still holds when we have multiple wires, but for now let us just state the color change rule more informally:
\begin{zxrule}\label{zx:colorchange}
	Put an $H$ gate on every wire input to or output from any phase pink or green dot.  The result is the same diagram, except the dot has now changed to the other of the two colors.
\end{zxrule}

\newpage
\begin{example}[]
	\label{ex:colorchange}
We would like to figure out what happens to a quantum circuit, when you ``push'' one of its gates past one of its neighboring gates.  In other words, if a gate A is to the left of a gate B, we want to end up with gate A on the right, which may change gate B.
\textnormal{We can apply our newest rewrite rules to get a new rewrite rule, which tells us what happens whenever we ``push'' an $H$ gate past an $X$ gate.}
\begin{equation}
	\tikzfig{circuitcommuteHX}
\end{equation}
\textnormal{How do we find out what belongs on the right hand side of the above equation?  One way is that we could multiply the matrices directly, as we have done so far.}

\textnormal{Another way is to run this directly on a quantum computer enough times for us to approximately reconstruct what the output state was (up to a global phase).
This is a technique known as \textbf{quantum state tomography}.  It is very useful for characterizing noise of quantum hardware and debugging quantum programs.  But in this case it would be overkill.}

\textnormal{There are other, more intuitive options we have not yet explored.  The circuit model is not expressive enough to enable us to prove this using just circuit model diagrams.  On the other hand, we can use just the rewrite rules of the ZX-calculus to compute this.}
\begin{equation}
	\tikzfig{zxcommuteHX}
\end{equation}
\textnormal{In the first line here, we have the circuit we start with, in the circuit model on the left, and in ZX-calcuclus on the right.  On the right half here, we apply one of our rewrite rules in each line, where inside the dashed gray box is where the rewrite rule is being applied.  Finally, we end up with the last line, and so we have ``pushed'' the $H$ gate through the $X$ gate, changing the $X$ gate into a $Z$ gate.}

\textnormal{In summary, we have proved that $XH = HZ$.  If that looks a little weird to you, that is because of an unfortunate case of the two most used conventions being opposite of each other.  Quantum circuits are drawn from left to right, but each time you apply a new gate you are multiplying the current state (which for pure qubit states is simply a column vector) on the left by the matrix of the new gate.}

\textnormal{As a final note for this example, here we walked through the case where the phase is $\pi$.  In fact, these exact rewrite rule steps are the same for any phase, such as was the case in Example~\ref{ex:othercolorchange}.}
\end{example}

\section{Qubits side by side}
Let us now take what we know about single-qubit states, and combine them to talk about multi-qubit states: quantum states of multiple qubits.
As of the time of writing this, IBM released Eagle, their 127 qubit quantum processor, becoming the first to take the number of qubits on a quantum computer to triple digits\footnote{\url{https://research.ibm.com/blog/127-qubit-quantum-processor-eagle}}.

We can classify any multi-qubit state as being either a \textbf{product state} or an \textbf{entangled state}.
We will first learn about product states, which are the special case of multi-quantum states with no entanglement.

\subsection{Product states}
So far, our diagrams of single-qubit states look like (here read from bottom to top, but we have also used the left-to-right convention before):

\begin{equation}
	\tikzfig{oneket}
\end{equation}

If we had two qubits respectively in the single-qubit states $\psi_0$ and $\psi_1$, their two-qubit state would be drawn as

\begin{equation}
	\tikzfig{twokets}
\end{equation}

So if we had $n$ unentangled qubits, their quantum state would be drawn as

\begin{equation}
	\tikzfig{nkets}
\end{equation}

What does it mean to draw qubit states side by side?

Conceptually, in our earlier analogy of quantum circuits to a cooking recipe, we start off with an ingredient (as our input states), do something to cook it (applying quantum gates), and end up with the cooked dish in the end (which we can ``consume'' or otherwise end its existence by eating it and observing how it tastes).
Our single-qubit quantum circuits are like dishes made of just one ingredient, which severely limits our options but can enjoyable at times.  Take for instance, eating a piece of toast:

\begin{equation}
	\tikzfig{onetoast}
\end{equation}

We can also eat more than one piece of toast at once:
\begin{equation}
	\tikzfig{twotoasts}
\end{equation}

Or any number of pieces of toast:
\begin{equation}
	\tikzfig{ntoasts}
\end{equation}

Each piece of toast is initially separate.  However, we can think of ``eat'' as an effect because it ``consumes'' the state, and thus we can think of this act of consumption as having as many inputs as the number of pieces of toast you are eating at once.

Now let us think of each piece of toast as being in a quantum state, let's just say it's the $\kz0$ state.
Then two separate pieces of toast would be our analogy for
\begin{equation}\label{eq:twok0s}
	\tikzfig{twok0s}
\end{equation}
What does this mean, physically and mathematically?

Physically, we \emph{are} talking about these two qubits being next to each other and not entangled with each other.
By ``next to'' we aren't referring to the distance between them.  It just means that they are part of the same system such that it makes sense to draw them together.  We are drawing them next to each other so we can draw them as disconnected if they are not entangled with each other.

Mathematically, this means that we take a \emph{tensor product}, also known as the Kronecker product, of the qubit states.  This simply means that we just need the individual statevectors $\ket{\psi_0},\ket{\psi_1},...\ket{\psi_{n-1}}$ to write the statevector of their combined system --- this is a product state because its statevector is their tensor product $\ket{\psi_0} \otimes \ket{\psi_1} \otimes ... \otimes \ket{\psi_{n-1}}$.  Below, we demonstrate an example of computing the tensor product.

In general if we take the tensor product of any two vectors
\begin{equation}
	\vec{v} = \begin{bmatrix}v_1\\ v_2\\ \vdots\\ v_m\end{bmatrix}
\end{equation}
and
\begin{equation}
	\vec{w} = \begin{bmatrix}w_1\\ w_2\\ \vdots\\ w_n\end{bmatrix}
\end{equation}
their tensor product is
\begin{align}
	\vec{v} \otimes \vec{w} &= \begin{bmatrix}v_1 \vec{w}\\ v_2 \vec{w}\\ \vdots \\ v_m \vec{w}\end{bmatrix}\\
	&= \begin{bmatrix}v_1 \begin{bmatrix}w_1\\ w_2\\ \vdots\\ w_n\end{bmatrix}\\ v_2 \begin{bmatrix}w_1\\ w_2\\ \vdots\\ w_n\end{bmatrix}\\ \vdots \\ v_m \begin{bmatrix}w_1\\ w_2\\ \vdots\\ w_n\end{bmatrix}\end{bmatrix}\\
	&= \begin{bmatrix}\begin{bmatrix}v_1 w_1\\ v_1 w_2\\ \vdots\\ v_1 w_n\end{bmatrix}\\ \begin{bmatrix}v_2 w_1\\ v_2 w_2\\ \vdots\\ v_2 w_n\end{bmatrix}\\ \vdots \\ v_m \begin{bmatrix}w_1\\ w_2\\ \vdots\\ w_n\end{bmatrix}\end{bmatrix}\\
	&= \begin{bmatrix}v_1 w_1\\ v_1 w_2\\ \vdots \\ v_1 w_n \\ v_2 w\end{bmatrix}
\end{align}
where two vectors stacked on top of each other means we are vertically concatenating them.
This can be thought of as a nested for loop multiplying the vectors together, where the outer for loop iterates through each element of $v$, while the inner for loop iterates through each element of $w$.

\begin{example}\label{ex:kz00}
	What is the statevector of a quantum system of two qubits each in the $\kz0$ state?
	\soln \textnormal{This is simply the product state drawn in Eq.~\eqref{eq:twok0s}, which is $\kz0 \otimes \kz0$:}
	\begin{align}
		\ket{\,0\,0\,} &= \kz0 \otimes \kz0\\
		&= \begin{bmatrix}1\\ 0\end{bmatrix} \otimes \begin{bmatrix}1\\ 0\end{bmatrix}\\
		&= \begin{bmatrix}1\begin{bmatrix}1\\ 0\end{bmatrix}\\ 0\begin{bmatrix}1\\ 0\end{bmatrix}\end{bmatrix}\\
		&= \begin{bmatrix}1\\ 0\\ 0\\ 0\end{bmatrix}
	\end{align}
	By convention, it is also written as $\ket{\,0\,0\,}$ because this is the quantum state that corresponds to the binary number $00$, when you have two bits that are both $0$.
\end{example}

Of course, just like how not everything we eat has to be toast (as that would be rather dull), we can make product states of individual qubits in different states as well.
We now demonstrate how to take tensor products of multiple qubits that can each have any statevector.

\begin{example}\label{ex:kzarb}
	What is the statevector of a quantum system of two qubits each with an arbitrary statevector?
	Let's say that
	\begin{equation}
		\ket{\psi_0} = \begin{bmatrix}a\\ b\end{bmatrix}
	\end{equation}
	and
	\begin{equation}
		\ket{\psi_1} = \begin{bmatrix}c\\ d\end{bmatrix}
	\end{equation}	
	\soln \textnormal{This is simply the product state $\ket{\psi_0} \otimes \ket{\psi_1}$:}
	\begin{align}
		\ket{\psi_0\,\psi_1} &= \ket{\psi_0} \otimes \ket{\psi_1}\\
		&= \begin{bmatrix}a\\ b\end{bmatrix} \otimes \begin{bmatrix}c\\ d\end{bmatrix}\\
		&= \begin{bmatrix}a\begin{bmatrix}c\\ d\end{bmatrix}\\\ b\begin{bmatrix}c\\ d\end{bmatrix}\end{bmatrix}\\
		&= \begin{bmatrix}ac\\ ad\\ bc\\ bd\end{bmatrix}
	\end{align}
	where $ab$ means multiplying the two complex numbers $a$ and $b$.
\end{example}

In general, to we can repeat taking the tensor product of many vectors to get the product state of even more qubits:
\begin{example}
	What is the statevector of a quantum system of three qubits each with an arbitrary statevector?
	Let's say that in addition to the two qubits in the previous example, we have a third qubit in the state
	\begin{equation}
		\ket{\psi_2} = \begin{bmatrix}f\\ g\end{bmatrix}
	\end{equation}
	\soln \textnormal{This is simply the product state $\ket{\psi_0} \otimes \ket{\psi_1} \otimes \ket{\psi_2}$:}
	\begin{align}
		\ket{\psi_0\,\psi_1\,\psi_2} &= \ket{\psi_0} \otimes \ket{\psi_1} \otimes \ket{\psi_2}\\
		&= (\ket{\psi_0} \otimes \ket{\psi_1}) \otimes \ket{\psi_2}\\
		&= \begin{bmatrix}ac\\ ad\\ bc\\ bd\end{bmatrix} \otimes \begin{bmatrix}f\\ g\end{bmatrix}\\
		&= \begin{bmatrix}ac\begin{bmatrix}f\\ g\end{bmatrix}\\ ad\begin{bmatrix}f\\ g\end{bmatrix}\\ bc\begin{bmatrix}f\\ g\end{bmatrix}\\ bd\begin{bmatrix}f\\ g\end{bmatrix}\end{bmatrix}\\
		&= \begin{bmatrix}acf\\ acg\\ adf\\ adg\\ bcf\\ bcg\\ bdf\\ bdg\end{bmatrix}
	\end{align}
	Note that the tensor product operation is associative, i.e. it doesn't matter the order we take the tensor product:
	\begin{equation}
		(\ket{\psi_0} \otimes \ket{\psi_1}) \otimes \ket{\psi_2} = \ket{\psi_0} \otimes (\ket{\psi_1} \otimes \ket{\psi_2})
	\end{equation}
\end{example}

In summary, if we have the statevectors of a bunch of qubits, we can compute their product state, drawn as their individual qubit states side by side:
\begin{equation}
	\tikzfig{nkets}
\end{equation}

In the circuit model, the way you draw multiple qubits is by having multiple horizontal wires, one for each qubit.
If you have $n$ qubits as drawn below, the convention in the Qiskit textbook and that we will use in this text, is to write their product state as: $\ket{q_{n-1}} \otimes \ket{q_{n-2}} \otimes ... \otimes \ket{q_0}$.
The other convention is to reverse the order: $\ket{q_0} \otimes \ket{q_1} \otimes ... \otimes \ket{q_{n-1}}$.
\begin{equation}
	\tikzfig{qubitordering_circuitmodel}
\end{equation}

\subsubsection{The two-qubit Z-basis states}
The four two-qubit Z-basis states are below.  They are the product states made up of one-qubit Z-basis states.
We did not write down each step of the computation here because it is as we did in Examples~\ref{ex:kz00}~and~\ref{ex:kzarb}.
\begin{align}
	\kz{00} &= \kz0 \otimes \kz0 = \begin{bmatrix}
		1\\
		0\\
		0\\
		0
	\end{bmatrix}\\
	\kz{01} &= \kz0 \otimes \kz1 = \begin{bmatrix}
		0\\
		1\\
		0\\
		0
	\end{bmatrix}\\
	\kz{10} &= \kz1 \otimes \kz0 = \begin{bmatrix}
		0\\
		0\\
		1\\
		0
	\end{bmatrix}\\
	\kz{11} &= \kz1 \otimes \kz1 = \begin{bmatrix}
		0\\
		0\\
		0\\
		1
	\end{bmatrix}
\end{align}	
We can generalize them to $n$-qubit Z-basis states corresponding to bitstrings of length $n$ by taking the tensor product of $n$ one-qubit Z-basis states.

\subsubsection{The two-qubit X-basis states}
Likewise, we can take product states of the X-basis states to get the $n$-qubit X-basis states, of which there are also $2^n$.
The two-qubit X-basis states are:
\begin{align}
	\kx{++} &= \kx+ \otimes \kx+ = \frac{1}{2} \ \begin{bmatrix}
		1\\
		1\\
		1\\
		1
	\end{bmatrix}\\
	\kx{+-} &= \kx+ \otimes \kx- = \frac{1}{2} \ \begin{bmatrix}
		1\\
		-1\\
		1\\
		-1
	\end{bmatrix}\\
	\kz{-+} &= \kx- \otimes \kx+ = \frac{1}{2} \ \begin{bmatrix}
		1\\
		1\\
		-1\\
		-1
	\end{bmatrix}\\
	\kx{--} &= \kx- \otimes \kx- = \frac{1}{2} \ \begin{bmatrix}
		1\\
		-1\\
		-1\\
		1
	\end{bmatrix}
\end{align}

\subsection{Entangled states}
You may think that it is not too useful that so far we have only described individual and separate qubits, and you would be right.
What we are getting to is how to make the qubits interact with each other in ways natural for quantum systems, but ``artificial'' and expensive to simulate on classical computers.
This leads us to quantum entanglement, something uniquely quantum that we use for quantum computation.

\subsubsection{The CX gate}
The most fundamental --- or at least, the most commonly used --- two-qubit gate is the CX gate.  CX is short for controlled X.  It is also called the CNOT gate, short for controlled NOT, because the X gate is also called the NOT gate.

We previously learned that the X gate exchanges $\kz0$ and $\kz1$, its eigenstates are $\kx+$ and $\kx-$, and its matrix is
\begin{equation}
	X = \begin{bmatrix}
		0 & 1\\
		1 & 0
	\end{bmatrix}
\end{equation}
There are two ways to draw the $X$ gate in the circuit model which can be used interchangeably and have the same meaning.
As with other named gates, we can draw a box with the label $X$ on it:
\begin{equation}
	\tikzfig{x_circuitmodel2}
\end{equation}
The other convention is this symbol:
\begin{equation}
	\tikzfig{x_circuitmodel}
\end{equation}

One of the qubits the CX gate acts upon is called the control qubit, and the other is called the target qubit.
What the CX gate does is that whether it does the X gate on the target qubit depends on the state of the control qubit.
There are two ways to write the matrix for the CX gate --- one if you order your bits by little Endian convention, and the other by big Endian.

If we have the CX gate act upon two qubits $q_c$ and $q_t$, with $q_c$ as the control qubit and $q_t$ as the target qubit, in the circuit model this would be drawn as
\begin{equation}
	\tikzfig{cx_circuitmodel}
\end{equation}
While also correct, this notation for the CX gate is less commonly seen:
\begin{equation}
	\tikzfig{cx_circuitmodel2}
\end{equation}
In general, you can draw any gate with a control qubit, by drawing a vertical line from the gate to a black dot on the wire of the control qubit.

In convention we use, the one used by the Qiskit textbook, the control qubit is on the right side of the tensor product, andn the target qubit is on the left.  Then the matrix of the CX gate is
\begin{equation}
	CX = \begin{bmatrix}
		1 & 0 & 0 & 0\\
		0 & 0 & 0 & 1\\
		0 & 0 & 1 & 0\\
		0 & 1 & 0 & 0
	\end{bmatrix}
\end{equation}
\begin{example}
	What does the CX gate do to the two-qubit Z-basis states?
	\soln \textnormal{The four two-qubit Z-basis states are $\ket{00}$, $\ket{10}$, $\ket{01}$, and $\ket{11}$.  We multiply them each by the matrix of the CX gate:}
	\begin{align}
		CX \kz{00} &= \begin{bmatrix}
			1 & 0 & 0 & 0\\
			0 & 0 & 0 & 1\\
			0 & 0 & 1 & 0\\
			0 & 1 & 0 & 0
		\end{bmatrix} \begin{bmatrix}
			1\\
			0\\
			0\\
			0
		\end{bmatrix} = \begin{bmatrix}
			1\\
			0\\
			0\\
			0
		\end{bmatrix} = \kz{00}\\
		CX \kz{01} &= \begin{bmatrix}
			1 & 0 & 0 & 0\\
			0 & 0 & 0 & 1\\
			0 & 0 & 1 & 0\\
			0 & 1 & 0 & 0
		\end{bmatrix} \begin{bmatrix}
			0\\
			1\\
			0\\
			0
		\end{bmatrix} = \begin{bmatrix}
			0\\
			0\\
			0\\
			1
		\end{bmatrix} = \kz{11}\\
		CX \kz{10} &= \begin{bmatrix}
			1 & 0 & 0 & 0\\
			0 & 0 & 0 & 1\\
			0 & 0 & 1 & 0\\
			0 & 1 & 0 & 0
		\end{bmatrix} \begin{bmatrix}
			0\\
			0\\
			1\\
			0
		\end{bmatrix} = \begin{bmatrix}
			0\\
			0\\
			1\\
			0
		\end{bmatrix} = \kz{10}\\
		CX \kz{11} &= \begin{bmatrix}
			1 & 0 & 0 & 0\\
			0 & 0 & 0 & 1\\
			0 & 0 & 1 & 0\\
			0 & 1 & 0 & 0
		\end{bmatrix} \begin{bmatrix}
			0\\
			0\\
			0\\
			1
		\end{bmatrix} = \begin{bmatrix}
			0\\
			1\\
			0\\
			0
		\end{bmatrix} = \kz{01}
	\end{align}
	We can describe the CX gate with a truth table, like we did before for classical gates such as AND and OR, because the CX gate sends each Z-basis state to a Z-basis state.  The truth table is:
	\begin{equation}
		\begin{tabular}{c|c||c|c} \multicolumn{2}{c|}{I} & \multicolumn{2}{|c}{O}\\
			\hline
			C & T & C & T\\
			\hline
			0 & 0 & 0 & 0\\
			0 & 1 & 0 & 1\\
			1 & 0 & 1 & 1\\
			1 & 1 & 1 & 0
		\end{tabular}
	\end{equation}
	\begin{note}
		Furthermore, the CX is an example of \textit{reversible classical gate} because it maps, one-to-one, each Z-basis state to a Z-basis state.
		You can easily check that it is indeed reversible because if you were told which of the Z-basis states was output (the right half of the above truth table), then you know what was the input Z-basis state to the CX gate to get that output.
		
		All quantum gates, including all that we have seen so far, are \textbf{reversible}.  This means that for each $n$-qubit quantum gate, there is a unique $n$-qubit quantum gate such that if you apply one after the other (in either order), you get the identity operation on $n$ qubits which let's call $I$ here.  As we will see below, this unique inverse operation is the complex conjugate matrix to $U$, $U^\dagger$.

		As we saw earlier, each single-qubit quantum gate sends a statevector on the surface of the Bloch sphere (i.e. a statevector of norm 1) to a statevector on the surface of the Bloch sphere.
		In fact, all quantum gates have this property: if you apply the same quantum gate to any two statevectors of the same length, their inner product before and after you applied that gate are the same.  This property is called \textbf{unitary}.
		This means that quantum gates preserve vector norms and thus also preserve probability amplitudes.

		We can see how these two properties of reversible and unitary coincide for complex number matrices.
		Consider an arbitary unitary matrix $U$ and a statevector of the same length $\ket{v}$.
		We know that because $U$ preserves vector norms, we must have that the norm of $\ket{Uv}=U\ket{v}$ is the same as the norm of $\ket{v}$.
		\begin{align}
			\langle \,v\,|\,v\,\rangle &= \langle \,U\,v\,|\,U\,v\,\rangle\\
			&= (U\ket{v})^\dagger U\ket{v}\\
			&= \ket{v}^\dagger U^\dagger U \ket{v}\\
			&= \bra{v} U^\dagger U \ket{v}
		\end{align}
		where in the second line we used the trick that for any two complex matrices or vectors $A$ and $B$ that can be multiplied together, $(AB)^\dagger = B^\dagger A^\dagger$.
		However, the above must hold for any complex vector of that length $v$, and so the above equation is true for every possible $v$ if and only if $U^\dagger U$ is the identity matrix $I$.  Indeed, $U^\dagger U = I = U U^\dagger$ for any unitary matrix $U$ and identity matrix $I$ of the same size as $U$.  Moreover, as matrix inverses of square matrices are unique, for any unitary matrix $U$, $U^\dagger$ is its unique matrix inverse i.e. $U^{-1}$.
	\end{note}
\end{example}

What if instead, the bottom qubit was the control and top qubit was the target?
Then the matrix of the upside-down CX gate would be
\begin{equation}
	CX = \begin{bmatrix}
		1 & 0 & 0 & 0\\
		0 & 1 & 0 & 0\\
		0 & 0 & 0 & 1\\
		0 & 0 & 1 & 0
	\end{bmatrix}
\end{equation}
This conveniently has a block diagonal form: We can chop the matrix into blocks where all the nonzero elements are in square blocks along the diagonal (from top left to bottom right) of the matrix.
	In this case, we have two such blocks.  The top left block is $\mathbb{I}$, the (one-qubit) identity matrix, while the bottom right block is the $X$ gate matrix:
	\begin{equation}
		{\renewcommand{\arraystretch}{1.5}
		CX = \left[ {\begin{array}{c|c}
			\ \ \mathbb{I} \ \ & \ \ \mathbb{O} \ \ \\ \hline
			\ \ \mathbb{O} \ \ & \ \ X \ \ \\
		\end{array} } \right]
		}
	\end{equation}
	where $\mathbb{O}$ is the 2 by 2 matrix of all zeros.

	\begin{note}
		If we had chosen the other convention for bit Endianness, then we would effectively swap which order the control and target qubits are in in our matrices.
		Therefore, the matrix for the CX gate in this other convention is the matrix for the upside-down CX gate in our convention.
		Likewise, the matrix for the upside-down CX gate in this other convention is the matrix for the CX gate in our convention.
	\end{note}

In the ZX-calculus, how we draw the CX gate is
\begin{equation}
	\tikzfig{zxCX}
\end{equation}

To capture how the CX gate acts upon the Z-basis states, we introduce a new rewrite rule of the ZX-calculus.
\begin{equation}
	\tikzfig{zxbialgebracopy} \quad \text{ and } \quad \tikzfig{zxbialgebracopypi}
\end{equation}

We can express this more concisely with the rewrite rule
\begin{zxrule}\label{zxrule:bialgebracopy}
	\begin{equation}
		\tikzfig{zxbialgebracopyapi}
	\end{equation}
	for $a \in \{0,1\}$.	
\end{zxrule}

This is our first time seeing a green dot with one input wire and two output wires.
It is known as the Z copy operation, because when you input to it a Z-basis state, it outputs two copies of that state.
Note that this only copies Z-basis states.  In fact, in quantum mechanics it is impossible to have any operation that copies any possible input, called the \textbf{no-cloning theorem}.

We know that the Z copy dot outputs $\kz{00}$ when the input is $\kz0$ and $\kz{11}$ when the input is $\kz1$.  Its matrix is thus
\begin{align}
	\kz{00} \bz0 + \kz{11} \bz1 &= \begin{bmatrix}
		1\\ 0\\ 0\\ 0
	\end{bmatrix} \begin{bmatrix}
		1 & 0
	\end{bmatrix} + \begin{bmatrix}
		0\\ 0\\ 0\\ 1
	\end{bmatrix} \begin{bmatrix}
		0 & 1
	\end{bmatrix}\\
	&= \begin{bmatrix}
		1 & 0\\
		0 & 0\\
		0 & 0\\
		0 & 1
	\end{bmatrix}
\end{align}
We can then multiply any arbitrary two-qubit quantum state by this matrix to determine what it does to that state.

There are a couple of variations on this rule to note.
First, as with all rules in standard ZX-calculus, you can interchange all green and pink colors.  This gives us the color-swapped version of Rule~\ref{zxrule:bialgebracopy}:
\begin{equation}
	\tikzfig{zxbialgebracopyapioppcolor}
\end{equation}
for $a \in \{0,1\}$ with matrix
\begin{align}
	\kx{++} \bx+ + \kx{--} \bx- &= \frac{1}{2} \begin{bmatrix}
		1\\ 1\\ 1\\ 1
	\end{bmatrix} \frac{1}{\sqrt{2}} \begin{bmatrix}
		1 & 1
	\end{bmatrix} + \frac{1}{2} \begin{bmatrix}
		1\\ -1\\ -1\\ 1
	\end{bmatrix}  \frac{1}{\sqrt{2}} \begin{bmatrix}
		1 & -1
	\end{bmatrix}\\
	&=  \frac{1}{\sqrt{2}} \begin{bmatrix}
		1 & 0\\
		0 & 1\\
		0 & 1\\
		1 & 0
	\end{bmatrix}
\end{align}
It is straightforward to check that this indeed produces two copies of $\kx+$ when the input is $\kx+$, and two copies of $\kx-$ when the input is $\kx-$.

We also can take the matrix's conjugate transpose, which in this case (because it's all real numbers here) is the same as tranpose, to get two more versions of this rule:
\begin{equation}
	\tikzfig{zxbialgebracopyapiT}
\end{equation}
and
\begin{equation}
	\tikzfig{zxbialgebracopyapioppcolorT}
\end{equation}

The above rules deal with inputting a Z- or X- basis state(s) into a dot of the opposite color.
What if the input state(s) are of the same color as the dot itself?  This is shown below for green, and holds just the same if all the dot colors were pink.
It is simply a matter of the spider fusion rule, which we now get to see in action for the case of more than one input wire.

First, now that we have a better understanding of what it means to have more than one wire at a time (i.e. multiple qubits!), we can take a look at the ultimate form of the spider fusion rule that we first informally described in ZX-calculus rule~\ref{zx:spider_fusion}.  This is what that looks like, diagrammatically:
\begin{equation}\label{eq:Z_spider_fusion}
	\tikzfig{Z_spider_fusion}
\end{equation}
Our dots now have arbitrary number of legs --- for that reason, we call them \emph{spiders}.
Here the $...$'s indicate there can be a variable number of legs.  For this ZX-calculus rule, you can have any number of legs wherever there are $...$'s here, as long as there is at least one wire between the two spiders you are fusing.  To give some intuition, if the two spiders are disconnected i.e. there is no path along wires from one to the other, then there is no way for quantum information to travel between the two spiders and so they cannot fuse.

We also have the multi-wire generalization of the color change rule, for which we showed the single-qubit version in Eq.~\eqref{eq:zxcolorchange}, and stated informally for the general case in ZX-calculus rule~\ref{zx:colorchange}:
\begin{equation}\label{eq:H_rule}
	\tikzfig{H_rule}
\end{equation}
The opposite color version of this rule can be derived in the same way as we did for the single-qubit case in Example~\eqref{ex:othercolorchange}, to get:
\begin{equation}\label{eq:H_rule_other}
	\tikzfig{H_rule_other}
\end{equation}

From our rules so far, we can see that $X$ spider fusion works exactly as $Z$ spider fusion does.
\begin{equation}\label{eq:X_spider_fusion}
	\tikzfig{X_spider_fusion}
\end{equation}

In the two input case, this adds together the bit values and can be thought of as a ``sum'' operation.
\begin{equation}
	\tikzfig{zxmatchsum}
\end{equation}

Indeed, this allows us to compute with the ZX-calculus what the CX gate does to the Z-basis states.
For any $c, t \in \{0,1\}$,
\begin{equation}
	\tikzfig{zxCXsum}
\end{equation}

Now consider the diagram below:
\begin{equation}
	\tikzfig{zxCXcopymatch}
\end{equation}
This sheds insight into a different way to view the CX gate, other than being if-then logic on whether or not to activate the X gate.
We can think of the CX gate as a ``sum'' gate when both inputs are Z-basis states.  Then it first makes a copy of the control qubit Z-basis state, which it adds to the target qubit Z-basis state in-place.
Note that $(c+t) \text{ mod } 2\pi$ will always be either $0$ or $\pi$.

The reason why we draw the CX gate vertically is not only due to convention, but because it doesn't matter which direction it is slanted.
Whether we view it as a Z copy then X match, or an X copy then Z match, does not affect the overall matrix:
\begin{equation}\label{eq:zxCXbendy}
	\tikzfig{zxCXbendy}
\end{equation}

The reason we can do this is that we can actually bend an output of a green or pink dot into an input, as if that wire was always an input to the dot in the first place:
\begin{equation}
	\tikzfig{zxcopybendy}
\end{equation}
We can do this to bend an input into an output too\footnote{In the standard ZX-calculus, this property that enables us to treat inputs and outputs of dots the same goes by a few names and subtle variations, such as ``Only Connectivity Matters'', ``Only Topology Matters'', or \emph{flexsymmetry}.}.

We can even express diagrammatically a more general statement about the CX gate, independent of the input target qubit state.
\begin{example}
	Show that when the control qubit is a Z-basis state, a CX gate performs an X gate on the target qubit if and only if the control qubit is in the $\kz1$ state.
	\soln \textnormal{We draw and simplify in the ZX-calculus, letting $c \in \{0,1\}$ denote whether the control qubit is $\kz0$ or $\kz1$.}
	\begin{equation}
		\tikzfig{zxCXcopy}
	\end{equation}
	Then, we break this down into the two possibilities, $c = 0$ or $c = 1$.\newline
	Case $c = 0$: The control qubit remains in the $\kz0$ state, and the target qubit is unchanged.
	Case $c = 1$: The control qubit remains in the $\kz1$ state, and the target qubit has an $X$ gate applied to it.
\end{example}

Yet another way we can use the ZX-calculus here is to know what the CX gate does on the X-basis states.
We can color change rewrite rule~\ref{zxrule:bialgebracopy}
\begin{equation}
	\tikzfig{zxbialgebracopyapih}
\end{equation}
Actually, in the standard ZX-calculus, any rewrite rule still holds if you invert all colors in the diagram between pink and green.

We thus see that the CX gate on the Z-basis states behaves just as with the X-basis states, except in the opposite direction of control and target.
\begin{equation}
	\tikzfig{zxCXcopyz}
\end{equation}
In other words, the CX gate does a $Z$ gate on the control qubit if and only if the target qubit is $\kx-$.

Just using the spider fusion rule of the ZX-calculus reveals further neat and otherwise non-obvious features of the CX gate.
Namely, we can commute any Z phase gate through the control of CX gate
\begin{equation}
	\tikzfig{zxCXZphase}
\end{equation}
and any X phase gate through the target of the CX gate
\begin{equation}
	\tikzfig{zxCXXphase}
\end{equation}
for arbitrary phase angle $\alpha$.
Recall that some of the most commonly encountered gates are Z phase gates (such as $Z$, $S$, and $T$) or X phase gates (such as $X$).

\subsubsection{The Bell state}
The first thing we will do with the CX gate is for building the \textbf{Bell state}.  Through this, we will learn what it means for two qubits to be \textbf{entangled}.

We could think of entanglement as making it possible for a two-qubit state to be indescribable by two one-qubit states.
This is in contrast to classical data, where if you have two bits and you know the values of both bits, then you know the value of their combined bitstring.
If we think about the analogy of circuits to cooking, we could imagine that a Bell state is like a jam sandwich.
\begin{equation*}
	\tikzfig{jamsandwich}
\end{equation*}
By spreading the jam onto the toast, you get something far tastier than just jam (blegh!), just toast (ehhh...), or just jam being next to toast.                             

The circuit to create a Bell state is
\begin{equation}\label{eq:Bellstate_circuitmodel}
	\tikzfig{Bellstate_circuitmodel}
\end{equation}

We can compute the resulting state by matrix multiplication:
\begin{align}
	CX \ (I \otimes H) \ \kz{00} &= \begin{bmatrix}
		1 & 0 & 0 & 0\\
		0 & 0 & 0 & 1\\
		0 & 0 & 1 & 0\\
		0 & 1 & 0 & 0
	\end{bmatrix} \ \left(\begin{bmatrix}
		1 & 0\\
		0 & 1
	\end{bmatrix} \otimes \frac{1}{\sqrt{2}}\begin{bmatrix}
		1 & 1\\
		1 & -1
	\end{bmatrix}\right) \ \begin{bmatrix}
		1\\
		0\\
		0\\
		0
	\end{bmatrix}\\
	&= \begin{bmatrix}
		1 & 0 & 0 & 0\\
		0 & 0 & 0 & 1\\
		0 & 0 & 1 & 0\\
		0 & 1 & 0 & 0
	\end{bmatrix} \ \begin{bmatrix}
		1\left(\frac{1}{\sqrt{2}}\begin{bmatrix}
			1 & 1\\
			1 & -1
		\end{bmatrix}\right) & 0\left(\frac{1}{\sqrt{2}}\begin{bmatrix}
			1 & 1\\
			1 & -1
		\end{bmatrix}\right)\\
		0\left(\frac{1}{\sqrt{2}}\begin{bmatrix}
			1 & 1\\
			1 & -1
		\end{bmatrix}\right) & 1\left(\frac{1}{\sqrt{2}}\begin{bmatrix}
			1 & 1\\
			1 & -1
		\end{bmatrix}\right)
	\end{bmatrix} \ \begin{bmatrix}
		1\\
		0\\
		0\\
		0
	\end{bmatrix}\\
	&= \begin{bmatrix}
		1 & 0 & 0 & 0\\
		0 & 0 & 0 & 1\\
		0 & 0 & 1 & 0\\
		0 & 1 & 0 & 0
	\end{bmatrix} \ \frac{1}{\sqrt{2}}\begin{bmatrix}
			1 & 1 & 0 & 0\\
			1 & -1 & 0 & 0\\
			0 & 0 & 1 & 1\\
			0 & 0 & 1 & -1
		\end{bmatrix} \ \begin{bmatrix}
		1\\
		0\\
		0\\
		0
	\end{bmatrix}\\
	&= \begin{bmatrix}
		1 & 0 & 0 & 0\\
		0 & 0 & 0 & 1\\
		0 & 0 & 1 & 0\\
		0 & 1 & 0 & 0
	\end{bmatrix} \ \frac{1}{\sqrt{2}}\begin{bmatrix}
			1\\
			1\\
			0\\
			0
		\end{bmatrix}\\
	&= \frac{1}{\sqrt{2}}\begin{bmatrix}
			1\\
			0\\
			0\\
			1
		\end{bmatrix}\\
	&= \frac{1}{\sqrt{2}} \left( \kz{00} + \kz{11} \right)
\end{align}
Thus, the above circuit creates the two-qubit state that is the equal superposition of both qubits being $\kz0$ and both being $\kz1$.
What happens when you observe them?
For fun, let us imagine that Alice and Bob are both cats.  Their qubits represent whether Alice cat and Bob cat are each grumpy (our analogy for $\kz0$) or happy (our analogy for $\kz1$)\footnote{This analogy and visualization were originally created by James Weaver at \url{https://slides.com/javafxpert/grumpy-and-happy-cats\#/12/0/2}, and is adapted here with his permission.}.
\begin{figure}[H]
	\label{fig:bellhappygrumpycat}
	\includegraphics[width=\columnwidth]{images/bellhappygrumpycat}
\end{figure}
\newpage
\begin{example}
	Two qubits are in the Bell state $\frac{1}{\sqrt{2}} \left(\kz{00} + \kz{11}\right)$.  Alice takes one of the qubits and flies to Venus.  Bob takes the other qubit and flies to Mars.  Alice and Bob each measure their qubit in the Z basis.  What are the possible outcomes of their measurements?
	\soln \textnormal{At the point of the circuit marked 1 in Figure~\ref{fig:bellhappygrumpycat}, the two-qubit state is}
	\begin{figure}[H]
		\includegraphics[width=0.5\columnwidth]{images/bellhappygrumpycat_stateatstep1}
	\end{figure}
	\textnormal{At the end of that circuit, marked 2, the two-qubit state is the Bell state:}
	\begin{figure}[H]
		\includegraphics[width=0.6\columnwidth]{images/bellhappygrumpycat_stateatstep2}
	\end{figure}
	\textnormal{When Alice and Bob each measure their qubit in the Z-basis, what happens to the Bell state is that it gets tested for the two-qubit Z-basis states: the tests are $\bz{00}$, $\bz{10}$, $\bz{01}$, and $\bz{11}$.  Thus, after they measure, they see which one of these four possibilities occurred.  The probabilities of each of these four measurement outcomes are:}
	\begin{align}
		\abs{\langle \,00\,|\,\frac{1}{\sqrt{2}} \left(\kz{00} + \kz{11}\right)\,\rangle}^2 &= \abs{\frac{1}{\sqrt{2}}\left( \langle \,00\,|\,00\,\rangle + \langle \,00\,|\,11\,\rangle \right)}^2\\
		&= \abs{\frac{1}{\sqrt{2}}\left( 1 + 0 \right)}^2\\
		&= \frac{1}{2}\\
		\abs{\langle \,10\,|\,\frac{1}{\sqrt{2}} \left(\kz{00} + \kz{11}\right)\,\rangle}^2 &= \abs{\frac{1}{\sqrt{2}}\left( \langle \,10\,|\,00\,\rangle + \langle \,10\,|\,11\,\rangle \right)}^2\\
		&= \abs{\frac{1}{\sqrt{2}}\left( 0 + 0 \right)}^2\\
		&= 0\\
		\abs{\langle \,01\,|\,\frac{1}{\sqrt{2}} \left(\kz{00} + \kz{11}\right)\,\rangle}^2 &= \abs{\frac{1}{\sqrt{2}}\left( \langle \,01\,|\,00\,\rangle + \langle \,01\,|\,11\,\rangle \right)}^2\\
		&= \abs{\frac{1}{\sqrt{2}}\left( 0 + 0 \right)}^2\\
		&= 0\\
		\abs{\langle \,11\,|\,\frac{1}{\sqrt{2}} \left(\kz{00} + \kz{11}\right)\,\rangle}^2 &= \abs{\frac{1}{\sqrt{2}}\left( \langle \,11\,|\,00\,\rangle + \langle \,11\,|\,11\,\rangle \right)}^2\\
		&= \abs{\frac{1}{\sqrt{2}}\left( 0 + 1 \right)}^2\\
		&= \frac{1}{2}
	\end{align}
\end{example}

This isn't specific to just measuring in the Z-basis.  We can repeat the same thought experiment, but now Alice and Bob both measure in the X-basis:
\begin{example}
	Two qubits are in the Bell state $\frac{1}{\sqrt{2}} \left(\kz{00} + \kz{11}\right)$.  Alice takes one of the qubits and flies to Venus.  Bob takes the other qubit and flies to Mars.  Alice and Bob again each measure their qubit, but this time in the X basis.  What are the possible outcomes of their measurements?
	\soln \textnormal{This time around, we are testing for the two-qubit X-basis states: $\bx{++}$, $\bx{-+}$, $\bx{+-}$, and $\bx{--}$.  In computing the measurement probabilities directly, we can make the calculation simpler by noting that the Bell state can be rewritten in the X-basis:}

	\begin{align}
		\frac{1}{\sqrt{2}} \left(\kx{++} + \kx{--}\right) &= \frac{1}{\sqrt{2}} \left(\left(\frac{1}{\sqrt{2}} \ \begin{bmatrix}
			1\\ 1
		\end{bmatrix} \otimes \begin{bmatrix}
			1\\ 1
		\end{bmatrix}\right) \ + \ \left(\frac{1}{\sqrt{2}} \ \begin{bmatrix}
			1\\ 1
		\end{bmatrix} \otimes \begin{bmatrix}
			1\\ 1
		\end{bmatrix}\right)\right)\\
		&= \frac{1}{\sqrt{2}} \left(\left(\frac{1}{2} \ \begin{bmatrix}
			1\\ 1\\ 1\\ 1\end{bmatrix}\right) \ + \ \left(\frac{1}{2} \ \begin{bmatrix}
				1\\ -1\\ -1\\ 1\end{bmatrix}\right)\right)\\
		&= \frac{1}{\sqrt{2}} \left(\begin{bmatrix}
			1\\ 0\\ 0\\ 1
		\end{bmatrix}\right)\\
		&= \frac{1}{\sqrt{2}} \left(\kz{00} + \kz{11}\right)
	\end{align}

	\textnormal{Then, the probabilities of these measurement outcomes are:}
	\begin{align}
		\abs{\langle \,++\,|\,\frac{1}{\sqrt{2}} \left(\kx{++} + \kx{--}\right)\,\rangle}^2 &= \abs{\frac{1}{\sqrt{2}}\left( \langle \,++\,|\,++\,\rangle + \langle \,++\,|\,--\,\rangle \right)}^2\\
		&= \abs{\frac{1}{\sqrt{2}}\left( 1 + 0 \right)}^2\\
		&= \frac{1}{2}\\
		\abs{\langle \,-+\,|\,\frac{1}{\sqrt{2}} \left(\kx{++} + \kx{--}\right)\,\rangle}^2 &= \abs{\frac{1}{\sqrt{2}}\left( \langle \,-+\,|\,++\,\rangle + \langle \,-+\,|\,--\,\rangle \right)}^2\\
		&= \abs{\frac{1}{\sqrt{2}}\left( 0 + 0 \right)}^2\\
		&= 0\\
		\abs{\langle \,+-\,|\,\frac{1}{\sqrt{2}} \left(\kx{++} + \kx{--}\right)\,\rangle}^2 &= \abs{\frac{1}{\sqrt{2}}\left( \langle \,+-\,|\,++\,\rangle + \langle \,+-\,|\,--\,\rangle \right)}^2\\
		&= \abs{\frac{1}{\sqrt{2}}\left( 0 + 0 \right)}^2\\
		&= 0\\
		\abs{\langle \,--\,|\,\frac{1}{\sqrt{2}} \left(\kx{++} + \kx{--}\right)\,\rangle}^2 &= \abs{\frac{1}{\sqrt{2}}\left( \langle \,--\,|\,++\,\rangle + \langle \,--\,|\,--\,\rangle \right)}^2\\
		&= \abs{\frac{1}{\sqrt{2}}\left( 0 + 1 \right)}^2\\
		&= \frac{1}{2}
	\end{align}
\end{example}

Although the Bell state is symmetric with respect to both qubits, as if we swap the two qubits the state is still the Bell state, this is not apparent from its circuit diagram in Eq.~\eqref{eq:Bellstate_circuitmodel}.  In the ZX-calculus, we draw the Bell state so you can easily see it is symmetric.  Actually, we can derive what the Bell state looks like in the ZX-calculus: First we convert the Bell state circuit to a ZX-calculus diagram; then, we simplify using the rules of the ZX-calculus.

When we convert the Bell state from circuit diagram to ZX diagram, we have two choices for the slant of the wire of the CX gate.  As we showed before in Eq.~\ref{eq:zxCXbendy}, either slant gives you the CX gate.
First, for the CX gate that is Z copy then X match:
\begin{equation}\label{eq:Bellstate_zx_z}
	\tikzfig{Bellstate_zx_z}
\end{equation}

Then, for the CX gate that is X copy then X match:
\begin{equation}\label{eq:Bellstate_zx_x}
	\tikzfig{Bellstate_zx_x}
\end{equation}

Both of these ZX diagrams are equal, because they are the same state --- the Bell state.  Combine this with the fact that phase gates with a phase of $0$ is the identity, from Eqs.~\eqref{eq:zxZI}~and~\eqref{eq:zxXI}:
\begin{equation}
	\tikzfig{zxZXI}
\end{equation}
For these reasons, we define the middle diagram below to also be a ZX diagram for the Bell state.
\begin{equation}\label{eq:Bellstate_zx}
	\tikzfig{Bellstate_zx}
\end{equation}
This is simply a wire with nothing on it, bent $180^{\degree}$!  Due to its shape, this is colloquially called a \textbf{cup} in ZX-calculus.

We can also define the corresponding Bell test by taking the conjugate transpose of the whole thing: $\frac{1}{\sqrt{2}} \left(\bz{00} + \bz{11}\right)$.
Following the exact same simplification steps in Eq.~\eqref{eq:Bellstate_zx}, we get what is colloquially called a \textbf{cap} in ZX-calculus.
\begin{equation}\label{eq:belltest}
	\tikzfig{Belltest_zx}
\end{equation}

Lets connect the cup and the cap to an arbitrary quantum map $f$, which let's call $f$ for function as it has at least one input wire and at least one output wire.  Here we show just one wire for simplicity, but the same rules hold when you have more wires.
\begin{equation}\label{eq:transpose_map_def}
	\tikzfig{transpose_map_def}
\end{equation}
The cup bends the input wire(s) to the map to become output(s), while the cap bends the output wire(s) of the map to become input(s).
If you imagine the wires being pulled straight,
\begin{figure}[H]
	\centering
	\includegraphics[width=0.3\columnwidth]{images/baryanking.png}\hfill
	\includegraphics[width=0.3\columnwidth]{images/baryanked.png}
\end{figure}
then the trapezoid-shaped map would be rotated $180^{\degree}$.

What does it mean to interchange the inputs and the outputs of a map?
Well, our maps are simply matrices.  If you interchange the inputs and the outputs of any matrix, the resulting matrix is actually the \emph{transpose} of the original matrix!
Therefore, we draw diagrammatically the transpose of a map to be the original map rotated $180^{\degree}$.
\begin{figure}[H]
	\centering
	\tikzfig{conjugateandtransposemaps}
	\caption{\textbf{Left: } Earlier on, in Fig.~\ref{fig:conjugateandtransposestates} and reprinted here, we showed how diagrammatically (bottom to top convention) the transpose, complex conjugate, and conjugate transpose of a state, are obtained by respectively rotating by $180^{\degree}$, reflecting horizontally, or reflecting vertically its diagram. \textbf{Right: } The exact same transformations apply to maps too, as shown here, giving us the diagrams for the transpose, complex conjugate, and conjugate transpose of that map.}
\end{figure}

To get the transpose of a map, we just needed to bend inputs into outputs and outputs into inputs --- we never specified which direction to bend the wires $180^{\degree}$.  Whichever way we bend the wires in our diagrams $180^{\degree}$, we get diagrams for the same map, the transpose of the original map:
\begin{equation}
	\tikzfig{transpose_maps}
\end{equation}

When we substitute the identity wire into Eq.~\eqref{eq:transpose_map_def}, we get
\begin{equation}\label{eq:yank}
	\tikzfig{yank}
\end{equation}
because the transpose of the identity map is just the identity map.

This equation also holds if we combine the cup and the cap another way for which you also end up with one input and one output:
\begin{equation}\label{eq:yank2}
	\tikzfig{yank2}
\end{equation}
While there are a number of ways to convince yourself of this, we show here a simple way.  This utilizes our Z dot fusion rule, and the fact that a one-input, one-output Z dot with phase 0 is the identity.
\begin{equation}
	\tikzfig{yankZ}
\end{equation}

Formally, the math of this bending is made possible by the \emph{snake equations} (also called the \emph{yanking equations}).  This even made a cameo in the snake scientist blackboards in the cartoon series Rick and Morty, albeit there are typos in that blackboard:
\begin{figure}[H]
	\includegraphics[width=\columnwidth]{images/snake-equation_rick-and-morty}
\end{figure}

Using the snake equations, we can show the following:
\begin{equation}
	\tikzfig{map_around_cup_transpose}
\end{equation}
Any map attached to one side of a cup, is equal to the transpose of that map attached to the other side of a cup.

Effectively, this means that you can slide any map around a cup so that it rotates $180^{\degree}$:
\begin{equation}
	\tikzfig{slide_map_around_cup}
\end{equation}
The same holds for sliding any map around a cap.  This allows us to slide maps along the bends of any wire like beads on a necklace.

\subsection{The Bell basis}
The Bell state (``the cup'') is something we can easily implement on quantum computers: As we described earlier, we simply initialize the two qubits to the $\kz0$ state, then apply an $H$ gate followed by a CX gate.
However, a complication arises when we try to implement the Bell test (``the cap'').
As you can see in Eq.~\eqref{eq:belltest}, the Bell test requires that we measure both qubits in the Z basis and get the result $\bz0$ for them both.
The problem is that each of these Z basis measurements has a $50\%$ chance of being in the $\kz0$ state, and a $50\%$ chance of being in the $\kz1$ state.
This means that to implement this Bell test, we have only a 1 in 4 chance of succeeding.

In quantum computing, this is called \textbf{post-selection} --- whenever we need to have a specific measurement outcome(s) to implement the desired circuit.  If we get any other measurement outcome, we have to either 1) throw away the whole circuit run, or if possible 2) salvage the run by applying the right correction gate to our circuit.

Case 1) is bad:  If you throw away your run for each undesirable post-selection measurement outcome, then you need to run your circuit an exponential number of times to succeed on every post-selection.

Case 2) solves this problem so that you do not have to throw away runs where you had any unwanted measurement outcomes.  However, you still want to generally use less post-selections because it is difficult engineering-wise to perform quantum gates based on previous measurement outcomes in the same run.  Support for this operation on today's quantum computers is either limited or non-existent.  However, this capability is being developed for future quantum computers, with the goal of being able to perform error correction to improve fidelity of quantum computations.

So if we want to implement the Bell test, we post-select on the right outcome, $\kz{00}$, only $25\%$ of the time.
What happens the other $75\%$ of the time?

We actually get three other two-qubit tests, each having a 1 in 4 chance of occurring.
We will later show the correction needed to implement the Bell test if we measure anything other than $\kz{00}$.
This is a feature, not a bug; in fact, it will enable us to do \emph{quantum teleportation}.

If our post-selection measurement outcome is $\kz{01}$, $\kz{10}$, or $\kz{11}$, respectively, we get the tests:
\begin{equation}
	\tikzfig{Belltest_zx01}
\end{equation}
\begin{equation}
	\tikzfig{Belltest_zx10}
\end{equation}
\begin{equation}
	\tikzfig{Belltest_zx11}
\end{equation}

This measurement is called a \textbf{Bell measurement}.  We call these four tests, which we get with equal probability, the four Bell tests.
Colloquially, whenever we say simply ``Bell test'', we are referring to the test for which both measurement outcomes are $\bz0$.
Reflecting these four horizontally, we get four two-qubit states.  These four all together are called the Bell basis:
\begin{equation}
	\tikzfig{Bell_basis_states}
\end{equation}

Earlier, by combining the cup and the cap, we got two snake equations in the shape of the letter `S' and in the shape of a backwards `S', respectively.
Now that we have four pairs of a cup and a cap each in the Bell basis, this gives us eight total snake equations.  Minus the two we have already shown in Eqs.~\eqref{eq:yank}~and~\eqref{eq:yank2}, the remaining six equations are:
\begin{equation}
	\tikzfig{yankBell_zx01}
\end{equation}
\begin{equation}
	\tikzfig{yankBell_zx10}
\end{equation}
\begin{equation}
	\tikzfig{yankBell_zx11}
\end{equation}

The best thing about wire bending is that it looks exactly as you expect, but it captures a deeper meaning that is otherwise hard to grasp.
It lets us visualize \textbf{state-map duality}.  We can take any state of two or more qubits, and bend one or more output wires $180^{\degree}$ to become input wires.  This transforms the original state, for which all wires are output wires, to a map, for which there is at least one input wire and at least one output wire.
\begin{equation}\label{eq:state-map-duality_state}
	\tikzfig{state-map-duality_state}
\end{equation}

As it is a duality, we can also go the opposite direction.  We can take any map, and bend all the input wires $180^{\degree}$ to become output wires.  What we end up with is a state, because all of the wires are output wires.
\begin{equation}
	\tikzfig{state-map-duality_map}
\end{equation}

In the above diagrams we just stuck to the cases of two wires, but this works for more wires too.
\begin{equation}
	\tikzfig{state-map-duality_gen}
\end{equation}

Applying Eq.~\eqref{eq:state-map-duality_state}, bending a wire of each of the four Bell states we get the four \textbf{Bell maps}.
\begin{equation}
	\tikzfig{Bellmaps}
\end{equation}

The big picture is: this structure of how cups and caps interact\footnote{There is an entire field of study called \textbf{category theory} which is dedicated to studying such structures and how they interact with each other.  The ZX-calculus was developed as a graphical calculus that resulted from understanding such structure underlying qubit quantum computation.}
is what enables us to bend wires freely.  So long as we maintain what is connected to what, adding twists and turns in the wires does not change the overall computation.  As an example, the following ZX diagrams are the same, computationally:
\begin{equation}
	\tikzfig{deformation-example}
\end{equation}

If you are a fan of the cartoon series Avatar: the Last Airbender, you may appreciate thinking about wire bending literally.
\begin{figure}[H]
	\centering
	\includegraphics{images/wirebending.png}
\end{figure}


% Outline of this subsubsection:
% \begin{itemize}
% 	\item Bell state circuit diagram: last? use of matrix multiplication to get $\kz{00} + \kz{11}$ Bob flies to Mars, Alice flies to Venus, we observe them both, and Alice and Bob cat are in the same state
% 	\item convert to ZX, simplify in ZX to get cup
% 	\item example of Bell state coins - first example of "wire bending"	
% \end{itemize}

% As shown here where we learned how to produce a Bell state, the CX gate enables us to entangle two qubits together.  But it can do more --- the CX gate enables us to entangle any number of qubits together.  For instance, if we entangle qubit 1 and qubit 2, a d then entangle qubit 2 and qubit 3, we can create an entangled state of three qubits.

% \subsubsection{The GHZ state}
% %%% GHZ state ZX proof


% If we are able to do on our quantum computing hardware, just one arbitrary two-qubit entangling gate and enough single-qubit gates, we can do (to be more precise, approximate to arbitrary precision) any type of quantum computation possible on any number of qubits.  Being able to do this is called \textbf{universal quantum computation}.  The most famous gate set that suffices for universal quantum computation is called the Clifford+$T$ gate set, which has the three Clifford gates CX, $S$, and $H$, plus the non-Clifford $T$ gate.

% Besides cutting down the number of gates we ever need to just four, three of which are single-qubit gates, what is particularly special as we noted earlier is that the Clifford group (which can be generated by CX, $S$, and $H$) is the subset of quantum gates that we can efficiently simulate on classical computers.



% %%% Comment on Einstein's famous quote, ``spooky action at a distance''



% Let's call a \emph{process theory} something you can describe with a diagram with many processes, which can be any combination of in sequence and/or in parallel, where each process has zero or more input(s) and output(s).  Whenever we have anything happening ``in parallel'' or ``next to each other'', we can describe their combined process with the tensor product of the separate processes.

% Calculating $\vec{v} \otimes \vec{w}$ directly for any two vectors $\vec{v} = (v_1, v_2, ..., v_m)$ and $\vec{w} = (w_1, w_2, ..., w_n)$ is straightforward: Just multiply the numbers $v_i$ and $v_j$ for each $i \in \{1,...,m\}$ and $j \in \{1,...,n\}$.  $\vec{v} \otimes \vec{w}$ is simply a single larger vector $(v_{11}, v_{12}, ..., v_{1n},v_{21},...,v_{2n},...v_{m1},...,v_{mn})$.



% a toast sandwich:

% \begin{equation}
% 	\tikzfig{toastsandwich}
% \end{equation}%%% toast, make sandwich, eat



% To take our cooking to new heights, we can have...\newline
% \newline
% drumroll...\newline
% \newline
% more than one ingredient.  Say, our cooking process could look like this (because as I write this I am getting hungry and thinking about sandwiches):

% \begin{equation}
% 	\tikzfig{avocadogrilledcheesesandwich}
% \end{equation}

% So in the gray dashed box, is the product state of our three starting ingredients: toast, cheese, and avocado.  With a little extra work, we can transform them into the ultimate avocado grilled cheese sandwich.

% What does it mathematically mean to draw qubit states side by side?
% The word ``product'' in the name refers to the \textbf{tensor product} (also called the \textbf{Kronecker product}).

% Let's say we have two arbitrary single-qubit vectors:
% v1 = [a; b] and v2 = [c; d]
% How you take their tensor product is:

% Since our pure single-qubit states are just vectors, to get their product state, we just take the tensor product of all their single-qubit statevectors.
% In bra-ket notation, our earlier vector from equation REF is
% By convention, we can drop the tensor products between the individual kets to make the notation more concise.


%At this time, if this is your first rodeo with Qiskit, check out the `Getting started with Qiskit' Jupyter notebook to walk through how to run your circuits on hardware, before we continue.  You can navigate to it by selecting the `New file +' button which opens up the Launcher.
%\begin{figure}[H]
%	\includegraphics[width=\columnwidth]{images/Launcher_IBMQuantumLab.PNG}
%\end{figure}

%\printbibliography

% \bibliographystyle{plain}
% \bibliography{qiskit+zx}
\end{document}
